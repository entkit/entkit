// Copyright 2019-present Facebook
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/diazoxide/ent-refine/examples/ent-project/ent/company"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/country"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/email"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/image"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/location"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/phone"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/predicate"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/product"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/schema/enums"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/vendor"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/warehouse"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/website"
	"github.com/google/uuid"
)

// CompanyWhereInput represents a where input for filtering Company queries.
type CompanyWhereInput struct {
	Predicates []predicate.Company  `json:"-"`
	Not        *CompanyWhereInput   `json:"not,omitempty"`
	Or         []*CompanyWhereInput `json:"or,omitempty"`
	And        []*CompanyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "countries" edge predicates.
	HasCountries     *bool                `json:"hasCountries,omitempty"`
	HasCountriesWith []*CountryWhereInput `json:"hasCountriesWith,omitempty"`

	// "phones" edge predicates.
	HasPhones     *bool              `json:"hasPhones,omitempty"`
	HasPhonesWith []*PhoneWhereInput `json:"hasPhonesWith,omitempty"`

	// "emails" edge predicates.
	HasEmails     *bool              `json:"hasEmails,omitempty"`
	HasEmailsWith []*EmailWhereInput `json:"hasEmailsWith,omitempty"`

	// "websites" edge predicates.
	HasWebsites     *bool                `json:"hasWebsites,omitempty"`
	HasWebsitesWith []*WebsiteWhereInput `json:"hasWebsitesWith,omitempty"`

	// "locations" edge predicates.
	HasLocations     *bool                 `json:"hasLocations,omitempty"`
	HasLocationsWith []*LocationWhereInput `json:"hasLocationsWith,omitempty"`

	// "logo_image" edge predicates.
	HasLogoImage     *bool              `json:"hasLogoImage,omitempty"`
	HasLogoImageWith []*ImageWhereInput `json:"hasLogoImageWith,omitempty"`

	// "cover_image" edge predicates.
	HasCoverImage     *bool              `json:"hasCoverImage,omitempty"`
	HasCoverImageWith []*ImageWhereInput `json:"hasCoverImageWith,omitempty"`

	// "gallery_images" edge predicates.
	HasGalleryImages     *bool              `json:"hasGalleryImages,omitempty"`
	HasGalleryImagesWith []*ImageWhereInput `json:"hasGalleryImagesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CompanyWhereInput) AddPredicates(predicates ...predicate.Company) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CompanyWhereInput filter on the CompanyQuery builder.
func (i *CompanyWhereInput) Filter(q *CompanyQuery) (*CompanyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCompanyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCompanyWhereInput is returned in case the CompanyWhereInput is empty.
var ErrEmptyCompanyWhereInput = errors.New("ent: empty predicate CompanyWhereInput")

// P returns a predicate for filtering companies.
// An error is returned if the input is empty or invalid.
func (i *CompanyWhereInput) P() (predicate.Company, error) {
	var predicates []predicate.Company
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, company.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Company, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, company.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Company, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, company.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, company.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, company.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, company.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, company.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, company.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, company.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, company.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, company.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, company.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, company.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, company.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, company.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, company.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, company.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, company.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, company.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, company.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, company.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, company.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, company.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, company.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, company.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, company.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, company.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, company.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, company.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, company.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, company.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, company.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, company.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, company.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, company.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, company.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, company.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasCountries != nil {
		p := company.HasCountries()
		if !*i.HasCountries {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountriesWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountriesWith))
		for _, w := range i.HasCountriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasCountriesWith(with...))
	}
	if i.HasPhones != nil {
		p := company.HasPhones()
		if !*i.HasPhones {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPhonesWith) > 0 {
		with := make([]predicate.Phone, 0, len(i.HasPhonesWith))
		for _, w := range i.HasPhonesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPhonesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasPhonesWith(with...))
	}
	if i.HasEmails != nil {
		p := company.HasEmails()
		if !*i.HasEmails {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmailsWith) > 0 {
		with := make([]predicate.Email, 0, len(i.HasEmailsWith))
		for _, w := range i.HasEmailsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmailsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasEmailsWith(with...))
	}
	if i.HasWebsites != nil {
		p := company.HasWebsites()
		if !*i.HasWebsites {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWebsitesWith) > 0 {
		with := make([]predicate.Website, 0, len(i.HasWebsitesWith))
		for _, w := range i.HasWebsitesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWebsitesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasWebsitesWith(with...))
	}
	if i.HasLocations != nil {
		p := company.HasLocations()
		if !*i.HasLocations {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationsWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationsWith))
		for _, w := range i.HasLocationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasLocationsWith(with...))
	}
	if i.HasLogoImage != nil {
		p := company.HasLogoImage()
		if !*i.HasLogoImage {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLogoImageWith) > 0 {
		with := make([]predicate.Image, 0, len(i.HasLogoImageWith))
		for _, w := range i.HasLogoImageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLogoImageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasLogoImageWith(with...))
	}
	if i.HasCoverImage != nil {
		p := company.HasCoverImage()
		if !*i.HasCoverImage {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCoverImageWith) > 0 {
		with := make([]predicate.Image, 0, len(i.HasCoverImageWith))
		for _, w := range i.HasCoverImageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCoverImageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasCoverImageWith(with...))
	}
	if i.HasGalleryImages != nil {
		p := company.HasGalleryImages()
		if !*i.HasGalleryImages {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGalleryImagesWith) > 0 {
		with := make([]predicate.Image, 0, len(i.HasGalleryImagesWith))
		for _, w := range i.HasGalleryImagesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGalleryImagesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasGalleryImagesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCompanyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return company.And(predicates...), nil
	}
}

// CountryWhereInput represents a where input for filtering Country queries.
type CountryWhereInput struct {
	Predicates []predicate.Country  `json:"-"`
	Not        *CountryWhereInput   `json:"not,omitempty"`
	Or         []*CountryWhereInput `json:"or,omitempty"`
	And        []*CountryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "companies" edge predicates.
	HasCompanies     *bool                `json:"hasCompanies,omitempty"`
	HasCompaniesWith []*CompanyWhereInput `json:"hasCompaniesWith,omitempty"`

	// "phones" edge predicates.
	HasPhones     *bool              `json:"hasPhones,omitempty"`
	HasPhonesWith []*PhoneWhereInput `json:"hasPhonesWith,omitempty"`

	// "emails" edge predicates.
	HasEmails     *bool              `json:"hasEmails,omitempty"`
	HasEmailsWith []*EmailWhereInput `json:"hasEmailsWith,omitempty"`

	// "websites" edge predicates.
	HasWebsites     *bool                `json:"hasWebsites,omitempty"`
	HasWebsitesWith []*WebsiteWhereInput `json:"hasWebsitesWith,omitempty"`

	// "locations" edge predicates.
	HasLocations     *bool                 `json:"hasLocations,omitempty"`
	HasLocationsWith []*LocationWhereInput `json:"hasLocationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CountryWhereInput) AddPredicates(predicates ...predicate.Country) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CountryWhereInput filter on the CountryQuery builder.
func (i *CountryWhereInput) Filter(q *CountryQuery) (*CountryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCountryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCountryWhereInput is returned in case the CountryWhereInput is empty.
var ErrEmptyCountryWhereInput = errors.New("ent: empty predicate CountryWhereInput")

// P returns a predicate for filtering countries.
// An error is returned if the input is empty or invalid.
func (i *CountryWhereInput) P() (predicate.Country, error) {
	var predicates []predicate.Country
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, country.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Country, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, country.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Country, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, country.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, country.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, country.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, country.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, country.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, country.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, country.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, country.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, country.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, country.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, country.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, country.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, country.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, country.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, country.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, country.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, country.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, country.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, country.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, country.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, country.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, country.NameContainsFold(*i.NameContainsFold))
	}
	if i.Code != nil {
		predicates = append(predicates, country.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, country.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, country.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, country.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, country.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, country.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, country.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, country.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, country.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, country.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, country.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, country.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, country.CodeContainsFold(*i.CodeContainsFold))
	}

	if i.HasCompanies != nil {
		p := country.HasCompanies()
		if !*i.HasCompanies {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompaniesWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompaniesWith))
		for _, w := range i.HasCompaniesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompaniesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasCompaniesWith(with...))
	}
	if i.HasPhones != nil {
		p := country.HasPhones()
		if !*i.HasPhones {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPhonesWith) > 0 {
		with := make([]predicate.Phone, 0, len(i.HasPhonesWith))
		for _, w := range i.HasPhonesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPhonesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasPhonesWith(with...))
	}
	if i.HasEmails != nil {
		p := country.HasEmails()
		if !*i.HasEmails {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmailsWith) > 0 {
		with := make([]predicate.Email, 0, len(i.HasEmailsWith))
		for _, w := range i.HasEmailsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmailsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasEmailsWith(with...))
	}
	if i.HasWebsites != nil {
		p := country.HasWebsites()
		if !*i.HasWebsites {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWebsitesWith) > 0 {
		with := make([]predicate.Website, 0, len(i.HasWebsitesWith))
		for _, w := range i.HasWebsitesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWebsitesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasWebsitesWith(with...))
	}
	if i.HasLocations != nil {
		p := country.HasLocations()
		if !*i.HasLocations {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationsWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationsWith))
		for _, w := range i.HasLocationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasLocationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCountryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return country.And(predicates...), nil
	}
}

// EmailWhereInput represents a where input for filtering Email queries.
type EmailWhereInput struct {
	Predicates []predicate.Email  `json:"-"`
	Not        *EmailWhereInput   `json:"not,omitempty"`
	Or         []*EmailWhereInput `json:"or,omitempty"`
	And        []*EmailWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EmailWhereInput) AddPredicates(predicates ...predicate.Email) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EmailWhereInput filter on the EmailQuery builder.
func (i *EmailWhereInput) Filter(q *EmailQuery) (*EmailQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEmailWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEmailWhereInput is returned in case the EmailWhereInput is empty.
var ErrEmptyEmailWhereInput = errors.New("ent: empty predicate EmailWhereInput")

// P returns a predicate for filtering emails.
// An error is returned if the input is empty or invalid.
func (i *EmailWhereInput) P() (predicate.Email, error) {
	var predicates []predicate.Email
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, email.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Email, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, email.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Email, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, email.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, email.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, email.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, email.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, email.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, email.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, email.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, email.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, email.IDLTE(*i.IDLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, email.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, email.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, email.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, email.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, email.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, email.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, email.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, email.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, email.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, email.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, email.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, email.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, email.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, email.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, email.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, email.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, email.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, email.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, email.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, email.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, email.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, email.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, email.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, email.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, email.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, email.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, email.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, email.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, email.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, email.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, email.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, email.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, email.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, email.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, email.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, email.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, email.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, email.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, email.AddressContainsFold(*i.AddressContainsFold))
	}

	if i.HasCompany != nil {
		p := email.HasCompany()
		if !*i.HasCompany {
			p = email.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, email.HasCompanyWith(with...))
	}
	if i.HasCountry != nil {
		p := email.HasCountry()
		if !*i.HasCountry {
			p = email.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, email.HasCountryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEmailWhereInput
	case 1:
		return predicates[0], nil
	default:
		return email.And(predicates...), nil
	}
}

// ImageWhereInput represents a where input for filtering Image queries.
type ImageWhereInput struct {
	Predicates []predicate.Image  `json:"-"`
	Not        *ImageWhereInput   `json:"not,omitempty"`
	Or         []*ImageWhereInput `json:"or,omitempty"`
	And        []*ImageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "original_url" field predicates.
	OriginalURL             *string  `json:"originalURL,omitempty"`
	OriginalURLNEQ          *string  `json:"originalURLNEQ,omitempty"`
	OriginalURLIn           []string `json:"originalURLIn,omitempty"`
	OriginalURLNotIn        []string `json:"originalURLNotIn,omitempty"`
	OriginalURLGT           *string  `json:"originalURLGT,omitempty"`
	OriginalURLGTE          *string  `json:"originalURLGTE,omitempty"`
	OriginalURLLT           *string  `json:"originalURLLT,omitempty"`
	OriginalURLLTE          *string  `json:"originalURLLTE,omitempty"`
	OriginalURLContains     *string  `json:"originalURLContains,omitempty"`
	OriginalURLHasPrefix    *string  `json:"originalURLHasPrefix,omitempty"`
	OriginalURLHasSuffix    *string  `json:"originalURLHasSuffix,omitempty"`
	OriginalURLEqualFold    *string  `json:"originalURLEqualFold,omitempty"`
	OriginalURLContainsFold *string  `json:"originalURLContainsFold,omitempty"`

	// "gallery_company" edge predicates.
	HasGalleryCompany     *bool                `json:"hasGalleryCompany,omitempty"`
	HasGalleryCompanyWith []*CompanyWhereInput `json:"hasGalleryCompanyWith,omitempty"`

	// "logo_company" edge predicates.
	HasLogoCompany     *bool                `json:"hasLogoCompany,omitempty"`
	HasLogoCompanyWith []*CompanyWhereInput `json:"hasLogoCompanyWith,omitempty"`

	// "cover_company" edge predicates.
	HasCoverCompany     *bool                `json:"hasCoverCompany,omitempty"`
	HasCoverCompanyWith []*CompanyWhereInput `json:"hasCoverCompanyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ImageWhereInput) AddPredicates(predicates ...predicate.Image) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ImageWhereInput filter on the ImageQuery builder.
func (i *ImageWhereInput) Filter(q *ImageQuery) (*ImageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyImageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyImageWhereInput is returned in case the ImageWhereInput is empty.
var ErrEmptyImageWhereInput = errors.New("ent: empty predicate ImageWhereInput")

// P returns a predicate for filtering images.
// An error is returned if the input is empty or invalid.
func (i *ImageWhereInput) P() (predicate.Image, error) {
	var predicates []predicate.Image
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, image.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Image, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, image.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Image, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, image.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, image.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, image.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, image.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, image.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, image.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, image.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, image.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, image.IDLTE(*i.IDLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, image.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, image.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, image.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, image.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, image.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, image.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, image.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, image.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, image.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, image.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, image.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, image.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, image.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.OriginalURL != nil {
		predicates = append(predicates, image.OriginalURLEQ(*i.OriginalURL))
	}
	if i.OriginalURLNEQ != nil {
		predicates = append(predicates, image.OriginalURLNEQ(*i.OriginalURLNEQ))
	}
	if len(i.OriginalURLIn) > 0 {
		predicates = append(predicates, image.OriginalURLIn(i.OriginalURLIn...))
	}
	if len(i.OriginalURLNotIn) > 0 {
		predicates = append(predicates, image.OriginalURLNotIn(i.OriginalURLNotIn...))
	}
	if i.OriginalURLGT != nil {
		predicates = append(predicates, image.OriginalURLGT(*i.OriginalURLGT))
	}
	if i.OriginalURLGTE != nil {
		predicates = append(predicates, image.OriginalURLGTE(*i.OriginalURLGTE))
	}
	if i.OriginalURLLT != nil {
		predicates = append(predicates, image.OriginalURLLT(*i.OriginalURLLT))
	}
	if i.OriginalURLLTE != nil {
		predicates = append(predicates, image.OriginalURLLTE(*i.OriginalURLLTE))
	}
	if i.OriginalURLContains != nil {
		predicates = append(predicates, image.OriginalURLContains(*i.OriginalURLContains))
	}
	if i.OriginalURLHasPrefix != nil {
		predicates = append(predicates, image.OriginalURLHasPrefix(*i.OriginalURLHasPrefix))
	}
	if i.OriginalURLHasSuffix != nil {
		predicates = append(predicates, image.OriginalURLHasSuffix(*i.OriginalURLHasSuffix))
	}
	if i.OriginalURLEqualFold != nil {
		predicates = append(predicates, image.OriginalURLEqualFold(*i.OriginalURLEqualFold))
	}
	if i.OriginalURLContainsFold != nil {
		predicates = append(predicates, image.OriginalURLContainsFold(*i.OriginalURLContainsFold))
	}

	if i.HasGalleryCompany != nil {
		p := image.HasGalleryCompany()
		if !*i.HasGalleryCompany {
			p = image.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGalleryCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasGalleryCompanyWith))
		for _, w := range i.HasGalleryCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGalleryCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, image.HasGalleryCompanyWith(with...))
	}
	if i.HasLogoCompany != nil {
		p := image.HasLogoCompany()
		if !*i.HasLogoCompany {
			p = image.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLogoCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasLogoCompanyWith))
		for _, w := range i.HasLogoCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLogoCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, image.HasLogoCompanyWith(with...))
	}
	if i.HasCoverCompany != nil {
		p := image.HasCoverCompany()
		if !*i.HasCoverCompany {
			p = image.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCoverCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCoverCompanyWith))
		for _, w := range i.HasCoverCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCoverCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, image.HasCoverCompanyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyImageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return image.And(predicates...), nil
	}
}

// LocationWhereInput represents a where input for filtering Location queries.
type LocationWhereInput struct {
	Predicates []predicate.Location  `json:"-"`
	Not        *LocationWhereInput   `json:"not,omitempty"`
	Or         []*LocationWhereInput `json:"or,omitempty"`
	And        []*LocationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "latitude" field predicates.
	Latitude      *float64  `json:"latitude,omitempty"`
	LatitudeNEQ   *float64  `json:"latitudeNEQ,omitempty"`
	LatitudeIn    []float64 `json:"latitudeIn,omitempty"`
	LatitudeNotIn []float64 `json:"latitudeNotIn,omitempty"`
	LatitudeGT    *float64  `json:"latitudeGT,omitempty"`
	LatitudeGTE   *float64  `json:"latitudeGTE,omitempty"`
	LatitudeLT    *float64  `json:"latitudeLT,omitempty"`
	LatitudeLTE   *float64  `json:"latitudeLTE,omitempty"`

	// "longitude" field predicates.
	Longitude      *float64  `json:"longitude,omitempty"`
	LongitudeNEQ   *float64  `json:"longitudeNEQ,omitempty"`
	LongitudeIn    []float64 `json:"longitudeIn,omitempty"`
	LongitudeNotIn []float64 `json:"longitudeNotIn,omitempty"`
	LongitudeGT    *float64  `json:"longitudeGT,omitempty"`
	LongitudeGTE   *float64  `json:"longitudeGTE,omitempty"`
	LongitudeLT    *float64  `json:"longitudeLT,omitempty"`
	LongitudeLTE   *float64  `json:"longitudeLTE,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "postcode" field predicates.
	Postcode             *string  `json:"postcode,omitempty"`
	PostcodeNEQ          *string  `json:"postcodeNEQ,omitempty"`
	PostcodeIn           []string `json:"postcodeIn,omitempty"`
	PostcodeNotIn        []string `json:"postcodeNotIn,omitempty"`
	PostcodeGT           *string  `json:"postcodeGT,omitempty"`
	PostcodeGTE          *string  `json:"postcodeGTE,omitempty"`
	PostcodeLT           *string  `json:"postcodeLT,omitempty"`
	PostcodeLTE          *string  `json:"postcodeLTE,omitempty"`
	PostcodeContains     *string  `json:"postcodeContains,omitempty"`
	PostcodeHasPrefix    *string  `json:"postcodeHasPrefix,omitempty"`
	PostcodeHasSuffix    *string  `json:"postcodeHasSuffix,omitempty"`
	PostcodeEqualFold    *string  `json:"postcodeEqualFold,omitempty"`
	PostcodeContainsFold *string  `json:"postcodeContainsFold,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "state" field predicates.
	State             *string  `json:"state,omitempty"`
	StateNEQ          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGT           *string  `json:"stateGT,omitempty"`
	StateGTE          *string  `json:"stateGTE,omitempty"`
	StateLT           *string  `json:"stateLT,omitempty"`
	StateLTE          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`

	// "suburb" field predicates.
	Suburb             *string  `json:"suburb,omitempty"`
	SuburbNEQ          *string  `json:"suburbNEQ,omitempty"`
	SuburbIn           []string `json:"suburbIn,omitempty"`
	SuburbNotIn        []string `json:"suburbNotIn,omitempty"`
	SuburbGT           *string  `json:"suburbGT,omitempty"`
	SuburbGTE          *string  `json:"suburbGTE,omitempty"`
	SuburbLT           *string  `json:"suburbLT,omitempty"`
	SuburbLTE          *string  `json:"suburbLTE,omitempty"`
	SuburbContains     *string  `json:"suburbContains,omitempty"`
	SuburbHasPrefix    *string  `json:"suburbHasPrefix,omitempty"`
	SuburbHasSuffix    *string  `json:"suburbHasSuffix,omitempty"`
	SuburbEqualFold    *string  `json:"suburbEqualFold,omitempty"`
	SuburbContainsFold *string  `json:"suburbContainsFold,omitempty"`

	// "street_type" field predicates.
	StreetType             *string  `json:"streetType,omitempty"`
	StreetTypeNEQ          *string  `json:"streetTypeNEQ,omitempty"`
	StreetTypeIn           []string `json:"streetTypeIn,omitempty"`
	StreetTypeNotIn        []string `json:"streetTypeNotIn,omitempty"`
	StreetTypeGT           *string  `json:"streetTypeGT,omitempty"`
	StreetTypeGTE          *string  `json:"streetTypeGTE,omitempty"`
	StreetTypeLT           *string  `json:"streetTypeLT,omitempty"`
	StreetTypeLTE          *string  `json:"streetTypeLTE,omitempty"`
	StreetTypeContains     *string  `json:"streetTypeContains,omitempty"`
	StreetTypeHasPrefix    *string  `json:"streetTypeHasPrefix,omitempty"`
	StreetTypeHasSuffix    *string  `json:"streetTypeHasSuffix,omitempty"`
	StreetTypeEqualFold    *string  `json:"streetTypeEqualFold,omitempty"`
	StreetTypeContainsFold *string  `json:"streetTypeContainsFold,omitempty"`

	// "street_name" field predicates.
	StreetName             *string  `json:"streetName,omitempty"`
	StreetNameNEQ          *string  `json:"streetNameNEQ,omitempty"`
	StreetNameIn           []string `json:"streetNameIn,omitempty"`
	StreetNameNotIn        []string `json:"streetNameNotIn,omitempty"`
	StreetNameGT           *string  `json:"streetNameGT,omitempty"`
	StreetNameGTE          *string  `json:"streetNameGTE,omitempty"`
	StreetNameLT           *string  `json:"streetNameLT,omitempty"`
	StreetNameLTE          *string  `json:"streetNameLTE,omitempty"`
	StreetNameContains     *string  `json:"streetNameContains,omitempty"`
	StreetNameHasPrefix    *string  `json:"streetNameHasPrefix,omitempty"`
	StreetNameHasSuffix    *string  `json:"streetNameHasSuffix,omitempty"`
	StreetNameEqualFold    *string  `json:"streetNameEqualFold,omitempty"`
	StreetNameContainsFold *string  `json:"streetNameContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LocationWhereInput) AddPredicates(predicates ...predicate.Location) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LocationWhereInput filter on the LocationQuery builder.
func (i *LocationWhereInput) Filter(q *LocationQuery) (*LocationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLocationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLocationWhereInput is returned in case the LocationWhereInput is empty.
var ErrEmptyLocationWhereInput = errors.New("ent: empty predicate LocationWhereInput")

// P returns a predicate for filtering locations.
// An error is returned if the input is empty or invalid.
func (i *LocationWhereInput) P() (predicate.Location, error) {
	var predicates []predicate.Location
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, location.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Location, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, location.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Location, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, location.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, location.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, location.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, location.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, location.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, location.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, location.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, location.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, location.IDLTE(*i.IDLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, location.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, location.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, location.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, location.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, location.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, location.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, location.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, location.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, location.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, location.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, location.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, location.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, location.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, location.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, location.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, location.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, location.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, location.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, location.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, location.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, location.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, location.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, location.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, location.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, location.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, location.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Latitude != nil {
		predicates = append(predicates, location.LatitudeEQ(*i.Latitude))
	}
	if i.LatitudeNEQ != nil {
		predicates = append(predicates, location.LatitudeNEQ(*i.LatitudeNEQ))
	}
	if len(i.LatitudeIn) > 0 {
		predicates = append(predicates, location.LatitudeIn(i.LatitudeIn...))
	}
	if len(i.LatitudeNotIn) > 0 {
		predicates = append(predicates, location.LatitudeNotIn(i.LatitudeNotIn...))
	}
	if i.LatitudeGT != nil {
		predicates = append(predicates, location.LatitudeGT(*i.LatitudeGT))
	}
	if i.LatitudeGTE != nil {
		predicates = append(predicates, location.LatitudeGTE(*i.LatitudeGTE))
	}
	if i.LatitudeLT != nil {
		predicates = append(predicates, location.LatitudeLT(*i.LatitudeLT))
	}
	if i.LatitudeLTE != nil {
		predicates = append(predicates, location.LatitudeLTE(*i.LatitudeLTE))
	}
	if i.Longitude != nil {
		predicates = append(predicates, location.LongitudeEQ(*i.Longitude))
	}
	if i.LongitudeNEQ != nil {
		predicates = append(predicates, location.LongitudeNEQ(*i.LongitudeNEQ))
	}
	if len(i.LongitudeIn) > 0 {
		predicates = append(predicates, location.LongitudeIn(i.LongitudeIn...))
	}
	if len(i.LongitudeNotIn) > 0 {
		predicates = append(predicates, location.LongitudeNotIn(i.LongitudeNotIn...))
	}
	if i.LongitudeGT != nil {
		predicates = append(predicates, location.LongitudeGT(*i.LongitudeGT))
	}
	if i.LongitudeGTE != nil {
		predicates = append(predicates, location.LongitudeGTE(*i.LongitudeGTE))
	}
	if i.LongitudeLT != nil {
		predicates = append(predicates, location.LongitudeLT(*i.LongitudeLT))
	}
	if i.LongitudeLTE != nil {
		predicates = append(predicates, location.LongitudeLTE(*i.LongitudeLTE))
	}
	if i.Address != nil {
		predicates = append(predicates, location.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, location.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, location.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, location.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, location.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, location.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, location.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, location.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, location.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, location.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, location.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, location.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, location.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.Postcode != nil {
		predicates = append(predicates, location.PostcodeEQ(*i.Postcode))
	}
	if i.PostcodeNEQ != nil {
		predicates = append(predicates, location.PostcodeNEQ(*i.PostcodeNEQ))
	}
	if len(i.PostcodeIn) > 0 {
		predicates = append(predicates, location.PostcodeIn(i.PostcodeIn...))
	}
	if len(i.PostcodeNotIn) > 0 {
		predicates = append(predicates, location.PostcodeNotIn(i.PostcodeNotIn...))
	}
	if i.PostcodeGT != nil {
		predicates = append(predicates, location.PostcodeGT(*i.PostcodeGT))
	}
	if i.PostcodeGTE != nil {
		predicates = append(predicates, location.PostcodeGTE(*i.PostcodeGTE))
	}
	if i.PostcodeLT != nil {
		predicates = append(predicates, location.PostcodeLT(*i.PostcodeLT))
	}
	if i.PostcodeLTE != nil {
		predicates = append(predicates, location.PostcodeLTE(*i.PostcodeLTE))
	}
	if i.PostcodeContains != nil {
		predicates = append(predicates, location.PostcodeContains(*i.PostcodeContains))
	}
	if i.PostcodeHasPrefix != nil {
		predicates = append(predicates, location.PostcodeHasPrefix(*i.PostcodeHasPrefix))
	}
	if i.PostcodeHasSuffix != nil {
		predicates = append(predicates, location.PostcodeHasSuffix(*i.PostcodeHasSuffix))
	}
	if i.PostcodeEqualFold != nil {
		predicates = append(predicates, location.PostcodeEqualFold(*i.PostcodeEqualFold))
	}
	if i.PostcodeContainsFold != nil {
		predicates = append(predicates, location.PostcodeContainsFold(*i.PostcodeContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, location.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, location.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, location.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, location.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, location.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, location.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, location.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, location.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, location.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, location.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, location.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, location.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, location.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.State != nil {
		predicates = append(predicates, location.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, location.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, location.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, location.StateNotIn(i.StateNotIn...))
	}
	if i.StateGT != nil {
		predicates = append(predicates, location.StateGT(*i.StateGT))
	}
	if i.StateGTE != nil {
		predicates = append(predicates, location.StateGTE(*i.StateGTE))
	}
	if i.StateLT != nil {
		predicates = append(predicates, location.StateLT(*i.StateLT))
	}
	if i.StateLTE != nil {
		predicates = append(predicates, location.StateLTE(*i.StateLTE))
	}
	if i.StateContains != nil {
		predicates = append(predicates, location.StateContains(*i.StateContains))
	}
	if i.StateHasPrefix != nil {
		predicates = append(predicates, location.StateHasPrefix(*i.StateHasPrefix))
	}
	if i.StateHasSuffix != nil {
		predicates = append(predicates, location.StateHasSuffix(*i.StateHasSuffix))
	}
	if i.StateEqualFold != nil {
		predicates = append(predicates, location.StateEqualFold(*i.StateEqualFold))
	}
	if i.StateContainsFold != nil {
		predicates = append(predicates, location.StateContainsFold(*i.StateContainsFold))
	}
	if i.Suburb != nil {
		predicates = append(predicates, location.SuburbEQ(*i.Suburb))
	}
	if i.SuburbNEQ != nil {
		predicates = append(predicates, location.SuburbNEQ(*i.SuburbNEQ))
	}
	if len(i.SuburbIn) > 0 {
		predicates = append(predicates, location.SuburbIn(i.SuburbIn...))
	}
	if len(i.SuburbNotIn) > 0 {
		predicates = append(predicates, location.SuburbNotIn(i.SuburbNotIn...))
	}
	if i.SuburbGT != nil {
		predicates = append(predicates, location.SuburbGT(*i.SuburbGT))
	}
	if i.SuburbGTE != nil {
		predicates = append(predicates, location.SuburbGTE(*i.SuburbGTE))
	}
	if i.SuburbLT != nil {
		predicates = append(predicates, location.SuburbLT(*i.SuburbLT))
	}
	if i.SuburbLTE != nil {
		predicates = append(predicates, location.SuburbLTE(*i.SuburbLTE))
	}
	if i.SuburbContains != nil {
		predicates = append(predicates, location.SuburbContains(*i.SuburbContains))
	}
	if i.SuburbHasPrefix != nil {
		predicates = append(predicates, location.SuburbHasPrefix(*i.SuburbHasPrefix))
	}
	if i.SuburbHasSuffix != nil {
		predicates = append(predicates, location.SuburbHasSuffix(*i.SuburbHasSuffix))
	}
	if i.SuburbEqualFold != nil {
		predicates = append(predicates, location.SuburbEqualFold(*i.SuburbEqualFold))
	}
	if i.SuburbContainsFold != nil {
		predicates = append(predicates, location.SuburbContainsFold(*i.SuburbContainsFold))
	}
	if i.StreetType != nil {
		predicates = append(predicates, location.StreetTypeEQ(*i.StreetType))
	}
	if i.StreetTypeNEQ != nil {
		predicates = append(predicates, location.StreetTypeNEQ(*i.StreetTypeNEQ))
	}
	if len(i.StreetTypeIn) > 0 {
		predicates = append(predicates, location.StreetTypeIn(i.StreetTypeIn...))
	}
	if len(i.StreetTypeNotIn) > 0 {
		predicates = append(predicates, location.StreetTypeNotIn(i.StreetTypeNotIn...))
	}
	if i.StreetTypeGT != nil {
		predicates = append(predicates, location.StreetTypeGT(*i.StreetTypeGT))
	}
	if i.StreetTypeGTE != nil {
		predicates = append(predicates, location.StreetTypeGTE(*i.StreetTypeGTE))
	}
	if i.StreetTypeLT != nil {
		predicates = append(predicates, location.StreetTypeLT(*i.StreetTypeLT))
	}
	if i.StreetTypeLTE != nil {
		predicates = append(predicates, location.StreetTypeLTE(*i.StreetTypeLTE))
	}
	if i.StreetTypeContains != nil {
		predicates = append(predicates, location.StreetTypeContains(*i.StreetTypeContains))
	}
	if i.StreetTypeHasPrefix != nil {
		predicates = append(predicates, location.StreetTypeHasPrefix(*i.StreetTypeHasPrefix))
	}
	if i.StreetTypeHasSuffix != nil {
		predicates = append(predicates, location.StreetTypeHasSuffix(*i.StreetTypeHasSuffix))
	}
	if i.StreetTypeEqualFold != nil {
		predicates = append(predicates, location.StreetTypeEqualFold(*i.StreetTypeEqualFold))
	}
	if i.StreetTypeContainsFold != nil {
		predicates = append(predicates, location.StreetTypeContainsFold(*i.StreetTypeContainsFold))
	}
	if i.StreetName != nil {
		predicates = append(predicates, location.StreetNameEQ(*i.StreetName))
	}
	if i.StreetNameNEQ != nil {
		predicates = append(predicates, location.StreetNameNEQ(*i.StreetNameNEQ))
	}
	if len(i.StreetNameIn) > 0 {
		predicates = append(predicates, location.StreetNameIn(i.StreetNameIn...))
	}
	if len(i.StreetNameNotIn) > 0 {
		predicates = append(predicates, location.StreetNameNotIn(i.StreetNameNotIn...))
	}
	if i.StreetNameGT != nil {
		predicates = append(predicates, location.StreetNameGT(*i.StreetNameGT))
	}
	if i.StreetNameGTE != nil {
		predicates = append(predicates, location.StreetNameGTE(*i.StreetNameGTE))
	}
	if i.StreetNameLT != nil {
		predicates = append(predicates, location.StreetNameLT(*i.StreetNameLT))
	}
	if i.StreetNameLTE != nil {
		predicates = append(predicates, location.StreetNameLTE(*i.StreetNameLTE))
	}
	if i.StreetNameContains != nil {
		predicates = append(predicates, location.StreetNameContains(*i.StreetNameContains))
	}
	if i.StreetNameHasPrefix != nil {
		predicates = append(predicates, location.StreetNameHasPrefix(*i.StreetNameHasPrefix))
	}
	if i.StreetNameHasSuffix != nil {
		predicates = append(predicates, location.StreetNameHasSuffix(*i.StreetNameHasSuffix))
	}
	if i.StreetNameEqualFold != nil {
		predicates = append(predicates, location.StreetNameEqualFold(*i.StreetNameEqualFold))
	}
	if i.StreetNameContainsFold != nil {
		predicates = append(predicates, location.StreetNameContainsFold(*i.StreetNameContainsFold))
	}

	if i.HasCompany != nil {
		p := location.HasCompany()
		if !*i.HasCompany {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasCompanyWith(with...))
	}
	if i.HasCountry != nil {
		p := location.HasCountry()
		if !*i.HasCountry {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasCountryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLocationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return location.And(predicates...), nil
	}
}

// PhoneWhereInput represents a where input for filtering Phone queries.
type PhoneWhereInput struct {
	Predicates []predicate.Phone  `json:"-"`
	Not        *PhoneWhereInput   `json:"not,omitempty"`
	Or         []*PhoneWhereInput `json:"or,omitempty"`
	And        []*PhoneWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "number" field predicates.
	Number             *string  `json:"number,omitempty"`
	NumberNEQ          *string  `json:"numberNEQ,omitempty"`
	NumberIn           []string `json:"numberIn,omitempty"`
	NumberNotIn        []string `json:"numberNotIn,omitempty"`
	NumberGT           *string  `json:"numberGT,omitempty"`
	NumberGTE          *string  `json:"numberGTE,omitempty"`
	NumberLT           *string  `json:"numberLT,omitempty"`
	NumberLTE          *string  `json:"numberLTE,omitempty"`
	NumberContains     *string  `json:"numberContains,omitempty"`
	NumberHasPrefix    *string  `json:"numberHasPrefix,omitempty"`
	NumberHasSuffix    *string  `json:"numberHasSuffix,omitempty"`
	NumberEqualFold    *string  `json:"numberEqualFold,omitempty"`
	NumberContainsFold *string  `json:"numberContainsFold,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PhoneWhereInput) AddPredicates(predicates ...predicate.Phone) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PhoneWhereInput filter on the PhoneQuery builder.
func (i *PhoneWhereInput) Filter(q *PhoneQuery) (*PhoneQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPhoneWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPhoneWhereInput is returned in case the PhoneWhereInput is empty.
var ErrEmptyPhoneWhereInput = errors.New("ent: empty predicate PhoneWhereInput")

// P returns a predicate for filtering phones.
// An error is returned if the input is empty or invalid.
func (i *PhoneWhereInput) P() (predicate.Phone, error) {
	var predicates []predicate.Phone
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, phone.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Phone, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, phone.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Phone, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, phone.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, phone.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, phone.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, phone.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, phone.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, phone.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, phone.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, phone.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, phone.IDLTE(*i.IDLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, phone.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, phone.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, phone.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, phone.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, phone.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, phone.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, phone.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, phone.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, phone.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, phone.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, phone.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, phone.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, phone.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, phone.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, phone.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, phone.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, phone.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, phone.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, phone.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, phone.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, phone.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, phone.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, phone.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, phone.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, phone.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, phone.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Number != nil {
		predicates = append(predicates, phone.NumberEQ(*i.Number))
	}
	if i.NumberNEQ != nil {
		predicates = append(predicates, phone.NumberNEQ(*i.NumberNEQ))
	}
	if len(i.NumberIn) > 0 {
		predicates = append(predicates, phone.NumberIn(i.NumberIn...))
	}
	if len(i.NumberNotIn) > 0 {
		predicates = append(predicates, phone.NumberNotIn(i.NumberNotIn...))
	}
	if i.NumberGT != nil {
		predicates = append(predicates, phone.NumberGT(*i.NumberGT))
	}
	if i.NumberGTE != nil {
		predicates = append(predicates, phone.NumberGTE(*i.NumberGTE))
	}
	if i.NumberLT != nil {
		predicates = append(predicates, phone.NumberLT(*i.NumberLT))
	}
	if i.NumberLTE != nil {
		predicates = append(predicates, phone.NumberLTE(*i.NumberLTE))
	}
	if i.NumberContains != nil {
		predicates = append(predicates, phone.NumberContains(*i.NumberContains))
	}
	if i.NumberHasPrefix != nil {
		predicates = append(predicates, phone.NumberHasPrefix(*i.NumberHasPrefix))
	}
	if i.NumberHasSuffix != nil {
		predicates = append(predicates, phone.NumberHasSuffix(*i.NumberHasSuffix))
	}
	if i.NumberEqualFold != nil {
		predicates = append(predicates, phone.NumberEqualFold(*i.NumberEqualFold))
	}
	if i.NumberContainsFold != nil {
		predicates = append(predicates, phone.NumberContainsFold(*i.NumberContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, phone.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, phone.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, phone.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, phone.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, phone.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, phone.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, phone.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, phone.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, phone.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, phone.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, phone.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, phone.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, phone.TypeContainsFold(*i.TypeContainsFold))
	}

	if i.HasCompany != nil {
		p := phone.HasCompany()
		if !*i.HasCompany {
			p = phone.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, phone.HasCompanyWith(with...))
	}
	if i.HasCountry != nil {
		p := phone.HasCountry()
		if !*i.HasCountry {
			p = phone.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, phone.HasCountryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPhoneWhereInput
	case 1:
		return predicates[0], nil
	default:
		return phone.And(predicates...), nil
	}
}

// ProductWhereInput represents a where input for filtering Product queries.
type ProductWhereInput struct {
	Predicates []predicate.Product  `json:"-"`
	Not        *ProductWhereInput   `json:"not,omitempty"`
	Or         []*ProductWhereInput `json:"or,omitempty"`
	And        []*ProductWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "image" field predicates.
	Image             *string  `json:"image,omitempty"`
	ImageNEQ          *string  `json:"imageNEQ,omitempty"`
	ImageIn           []string `json:"imageIn,omitempty"`
	ImageNotIn        []string `json:"imageNotIn,omitempty"`
	ImageGT           *string  `json:"imageGT,omitempty"`
	ImageGTE          *string  `json:"imageGTE,omitempty"`
	ImageLT           *string  `json:"imageLT,omitempty"`
	ImageLTE          *string  `json:"imageLTE,omitempty"`
	ImageContains     *string  `json:"imageContains,omitempty"`
	ImageHasPrefix    *string  `json:"imageHasPrefix,omitempty"`
	ImageHasSuffix    *string  `json:"imageHasSuffix,omitempty"`
	ImageEqualFold    *string  `json:"imageEqualFold,omitempty"`
	ImageContainsFold *string  `json:"imageContainsFold,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "last_sell" field predicates.
	LastSell       *time.Time  `json:"lastSell,omitempty"`
	LastSellNEQ    *time.Time  `json:"lastSellNEQ,omitempty"`
	LastSellIn     []time.Time `json:"lastSellIn,omitempty"`
	LastSellNotIn  []time.Time `json:"lastSellNotIn,omitempty"`
	LastSellGT     *time.Time  `json:"lastSellGT,omitempty"`
	LastSellGTE    *time.Time  `json:"lastSellGTE,omitempty"`
	LastSellLT     *time.Time  `json:"lastSellLT,omitempty"`
	LastSellLTE    *time.Time  `json:"lastSellLTE,omitempty"`
	LastSellIsNil  bool        `json:"lastSellIsNil,omitempty"`
	LastSellNotNil bool        `json:"lastSellNotNil,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "status" field predicates.
	Status      *enums.ProcessStatus  `json:"status,omitempty"`
	StatusNEQ   *enums.ProcessStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ProcessStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ProcessStatus `json:"statusNotIn,omitempty"`

	// "build_status" field predicates.
	BuildStatus      *enums.ProcessStatus  `json:"buildStatus,omitempty"`
	BuildStatusNEQ   *enums.ProcessStatus  `json:"buildStatusNEQ,omitempty"`
	BuildStatusIn    []enums.ProcessStatus `json:"buildStatusIn,omitempty"`
	BuildStatusNotIn []enums.ProcessStatus `json:"buildStatusNotIn,omitempty"`

	// "warehouse" edge predicates.
	HasWarehouse     *bool                  `json:"hasWarehouse,omitempty"`
	HasWarehouseWith []*WarehouseWhereInput `json:"hasWarehouseWith,omitempty"`

	// "vendor" edge predicates.
	HasVendor     *bool               `json:"hasVendor,omitempty"`
	HasVendorWith []*VendorWhereInput `json:"hasVendorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductWhereInput) AddPredicates(predicates ...predicate.Product) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductWhereInput filter on the ProductQuery builder.
func (i *ProductWhereInput) Filter(q *ProductQuery) (*ProductQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductWhereInput is returned in case the ProductWhereInput is empty.
var ErrEmptyProductWhereInput = errors.New("ent: empty predicate ProductWhereInput")

// P returns a predicate for filtering products.
// An error is returned if the input is empty or invalid.
func (i *ProductWhereInput) P() (predicate.Product, error) {
	var predicates []predicate.Product
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, product.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Product, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, product.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Product, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, product.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, product.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, product.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, product.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, product.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, product.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, product.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, product.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, product.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, product.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, product.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, product.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, product.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, product.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, product.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, product.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, product.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, product.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, product.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, product.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, product.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, product.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, product.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, product.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, product.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, product.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, product.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, product.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, product.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, product.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, product.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, product.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, product.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, product.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, product.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Image != nil {
		predicates = append(predicates, product.ImageEQ(*i.Image))
	}
	if i.ImageNEQ != nil {
		predicates = append(predicates, product.ImageNEQ(*i.ImageNEQ))
	}
	if len(i.ImageIn) > 0 {
		predicates = append(predicates, product.ImageIn(i.ImageIn...))
	}
	if len(i.ImageNotIn) > 0 {
		predicates = append(predicates, product.ImageNotIn(i.ImageNotIn...))
	}
	if i.ImageGT != nil {
		predicates = append(predicates, product.ImageGT(*i.ImageGT))
	}
	if i.ImageGTE != nil {
		predicates = append(predicates, product.ImageGTE(*i.ImageGTE))
	}
	if i.ImageLT != nil {
		predicates = append(predicates, product.ImageLT(*i.ImageLT))
	}
	if i.ImageLTE != nil {
		predicates = append(predicates, product.ImageLTE(*i.ImageLTE))
	}
	if i.ImageContains != nil {
		predicates = append(predicates, product.ImageContains(*i.ImageContains))
	}
	if i.ImageHasPrefix != nil {
		predicates = append(predicates, product.ImageHasPrefix(*i.ImageHasPrefix))
	}
	if i.ImageHasSuffix != nil {
		predicates = append(predicates, product.ImageHasSuffix(*i.ImageHasSuffix))
	}
	if i.ImageEqualFold != nil {
		predicates = append(predicates, product.ImageEqualFold(*i.ImageEqualFold))
	}
	if i.ImageContainsFold != nil {
		predicates = append(predicates, product.ImageContainsFold(*i.ImageContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, product.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, product.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, product.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, product.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, product.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, product.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, product.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, product.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, product.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, product.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, product.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, product.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, product.URLContainsFold(*i.URLContainsFold))
	}
	if i.LastSell != nil {
		predicates = append(predicates, product.LastSellEQ(*i.LastSell))
	}
	if i.LastSellNEQ != nil {
		predicates = append(predicates, product.LastSellNEQ(*i.LastSellNEQ))
	}
	if len(i.LastSellIn) > 0 {
		predicates = append(predicates, product.LastSellIn(i.LastSellIn...))
	}
	if len(i.LastSellNotIn) > 0 {
		predicates = append(predicates, product.LastSellNotIn(i.LastSellNotIn...))
	}
	if i.LastSellGT != nil {
		predicates = append(predicates, product.LastSellGT(*i.LastSellGT))
	}
	if i.LastSellGTE != nil {
		predicates = append(predicates, product.LastSellGTE(*i.LastSellGTE))
	}
	if i.LastSellLT != nil {
		predicates = append(predicates, product.LastSellLT(*i.LastSellLT))
	}
	if i.LastSellLTE != nil {
		predicates = append(predicates, product.LastSellLTE(*i.LastSellLTE))
	}
	if i.LastSellIsNil {
		predicates = append(predicates, product.LastSellIsNil())
	}
	if i.LastSellNotNil {
		predicates = append(predicates, product.LastSellNotNil())
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, product.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, product.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, product.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, product.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, product.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, product.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, product.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, product.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, product.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, product.CreatedAtNotNil())
	}
	if i.Status != nil {
		predicates = append(predicates, product.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, product.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, product.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, product.StatusNotIn(i.StatusNotIn...))
	}
	if i.BuildStatus != nil {
		predicates = append(predicates, product.BuildStatusEQ(*i.BuildStatus))
	}
	if i.BuildStatusNEQ != nil {
		predicates = append(predicates, product.BuildStatusNEQ(*i.BuildStatusNEQ))
	}
	if len(i.BuildStatusIn) > 0 {
		predicates = append(predicates, product.BuildStatusIn(i.BuildStatusIn...))
	}
	if len(i.BuildStatusNotIn) > 0 {
		predicates = append(predicates, product.BuildStatusNotIn(i.BuildStatusNotIn...))
	}

	if i.HasWarehouse != nil {
		p := product.HasWarehouse()
		if !*i.HasWarehouse {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWarehouseWith) > 0 {
		with := make([]predicate.Warehouse, 0, len(i.HasWarehouseWith))
		for _, w := range i.HasWarehouseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWarehouseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasWarehouseWith(with...))
	}
	if i.HasVendor != nil {
		p := product.HasVendor()
		if !*i.HasVendor {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVendorWith) > 0 {
		with := make([]predicate.Vendor, 0, len(i.HasVendorWith))
		for _, w := range i.HasVendorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVendorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasVendorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductWhereInput
	case 1:
		return predicates[0], nil
	default:
		return product.And(predicates...), nil
	}
}

// VendorWhereInput represents a where input for filtering Vendor queries.
type VendorWhereInput struct {
	Predicates []predicate.Vendor  `json:"-"`
	Not        *VendorWhereInput   `json:"not,omitempty"`
	Or         []*VendorWhereInput `json:"or,omitempty"`
	And        []*VendorWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "schema" field predicates.
	Schema             *string  `json:"schema,omitempty"`
	SchemaNEQ          *string  `json:"schemaNEQ,omitempty"`
	SchemaIn           []string `json:"schemaIn,omitempty"`
	SchemaNotIn        []string `json:"schemaNotIn,omitempty"`
	SchemaGT           *string  `json:"schemaGT,omitempty"`
	SchemaGTE          *string  `json:"schemaGTE,omitempty"`
	SchemaLT           *string  `json:"schemaLT,omitempty"`
	SchemaLTE          *string  `json:"schemaLTE,omitempty"`
	SchemaContains     *string  `json:"schemaContains,omitempty"`
	SchemaHasPrefix    *string  `json:"schemaHasPrefix,omitempty"`
	SchemaHasSuffix    *string  `json:"schemaHasSuffix,omitempty"`
	SchemaEqualFold    *string  `json:"schemaEqualFold,omitempty"`
	SchemaContainsFold *string  `json:"schemaContainsFold,omitempty"`

	// "warehouses" edge predicates.
	HasWarehouses     *bool                  `json:"hasWarehouses,omitempty"`
	HasWarehousesWith []*WarehouseWhereInput `json:"hasWarehousesWith,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *VendorWhereInput) AddPredicates(predicates ...predicate.Vendor) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the VendorWhereInput filter on the VendorQuery builder.
func (i *VendorWhereInput) Filter(q *VendorQuery) (*VendorQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyVendorWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyVendorWhereInput is returned in case the VendorWhereInput is empty.
var ErrEmptyVendorWhereInput = errors.New("ent: empty predicate VendorWhereInput")

// P returns a predicate for filtering vendors.
// An error is returned if the input is empty or invalid.
func (i *VendorWhereInput) P() (predicate.Vendor, error) {
	var predicates []predicate.Vendor
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, vendor.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Vendor, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, vendor.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Vendor, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, vendor.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, vendor.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vendor.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vendor.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vendor.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vendor.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vendor.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vendor.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vendor.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, vendor.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, vendor.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, vendor.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, vendor.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, vendor.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, vendor.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, vendor.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, vendor.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, vendor.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, vendor.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, vendor.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, vendor.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, vendor.NameContainsFold(*i.NameContainsFold))
	}
	if i.Schema != nil {
		predicates = append(predicates, vendor.SchemaEQ(*i.Schema))
	}
	if i.SchemaNEQ != nil {
		predicates = append(predicates, vendor.SchemaNEQ(*i.SchemaNEQ))
	}
	if len(i.SchemaIn) > 0 {
		predicates = append(predicates, vendor.SchemaIn(i.SchemaIn...))
	}
	if len(i.SchemaNotIn) > 0 {
		predicates = append(predicates, vendor.SchemaNotIn(i.SchemaNotIn...))
	}
	if i.SchemaGT != nil {
		predicates = append(predicates, vendor.SchemaGT(*i.SchemaGT))
	}
	if i.SchemaGTE != nil {
		predicates = append(predicates, vendor.SchemaGTE(*i.SchemaGTE))
	}
	if i.SchemaLT != nil {
		predicates = append(predicates, vendor.SchemaLT(*i.SchemaLT))
	}
	if i.SchemaLTE != nil {
		predicates = append(predicates, vendor.SchemaLTE(*i.SchemaLTE))
	}
	if i.SchemaContains != nil {
		predicates = append(predicates, vendor.SchemaContains(*i.SchemaContains))
	}
	if i.SchemaHasPrefix != nil {
		predicates = append(predicates, vendor.SchemaHasPrefix(*i.SchemaHasPrefix))
	}
	if i.SchemaHasSuffix != nil {
		predicates = append(predicates, vendor.SchemaHasSuffix(*i.SchemaHasSuffix))
	}
	if i.SchemaEqualFold != nil {
		predicates = append(predicates, vendor.SchemaEqualFold(*i.SchemaEqualFold))
	}
	if i.SchemaContainsFold != nil {
		predicates = append(predicates, vendor.SchemaContainsFold(*i.SchemaContainsFold))
	}

	if i.HasWarehouses != nil {
		p := vendor.HasWarehouses()
		if !*i.HasWarehouses {
			p = vendor.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWarehousesWith) > 0 {
		with := make([]predicate.Warehouse, 0, len(i.HasWarehousesWith))
		for _, w := range i.HasWarehousesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWarehousesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, vendor.HasWarehousesWith(with...))
	}
	if i.HasProducts != nil {
		p := vendor.HasProducts()
		if !*i.HasProducts {
			p = vendor.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, vendor.HasProductsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyVendorWhereInput
	case 1:
		return predicates[0], nil
	default:
		return vendor.And(predicates...), nil
	}
}

// WarehouseWhereInput represents a where input for filtering Warehouse queries.
type WarehouseWhereInput struct {
	Predicates []predicate.Warehouse  `json:"-"`
	Not        *WarehouseWhereInput   `json:"not,omitempty"`
	Or         []*WarehouseWhereInput `json:"or,omitempty"`
	And        []*WarehouseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "last_update" field predicates.
	LastUpdate       *time.Time  `json:"lastUpdate,omitempty"`
	LastUpdateNEQ    *time.Time  `json:"lastUpdateNEQ,omitempty"`
	LastUpdateIn     []time.Time `json:"lastUpdateIn,omitempty"`
	LastUpdateNotIn  []time.Time `json:"lastUpdateNotIn,omitempty"`
	LastUpdateGT     *time.Time  `json:"lastUpdateGT,omitempty"`
	LastUpdateGTE    *time.Time  `json:"lastUpdateGTE,omitempty"`
	LastUpdateLT     *time.Time  `json:"lastUpdateLT,omitempty"`
	LastUpdateLTE    *time.Time  `json:"lastUpdateLTE,omitempty"`
	LastUpdateIsNil  bool        `json:"lastUpdateIsNil,omitempty"`
	LastUpdateNotNil bool        `json:"lastUpdateNotNil,omitempty"`

	// "original_data" field predicates.
	OriginalData             *string  `json:"originalData,omitempty"`
	OriginalDataNEQ          *string  `json:"originalDataNEQ,omitempty"`
	OriginalDataIn           []string `json:"originalDataIn,omitempty"`
	OriginalDataNotIn        []string `json:"originalDataNotIn,omitempty"`
	OriginalDataGT           *string  `json:"originalDataGT,omitempty"`
	OriginalDataGTE          *string  `json:"originalDataGTE,omitempty"`
	OriginalDataLT           *string  `json:"originalDataLT,omitempty"`
	OriginalDataLTE          *string  `json:"originalDataLTE,omitempty"`
	OriginalDataContains     *string  `json:"originalDataContains,omitempty"`
	OriginalDataHasPrefix    *string  `json:"originalDataHasPrefix,omitempty"`
	OriginalDataHasSuffix    *string  `json:"originalDataHasSuffix,omitempty"`
	OriginalDataIsNil        bool     `json:"originalDataIsNil,omitempty"`
	OriginalDataNotNil       bool     `json:"originalDataNotNil,omitempty"`
	OriginalDataEqualFold    *string  `json:"originalDataEqualFold,omitempty"`
	OriginalDataContainsFold *string  `json:"originalDataContainsFold,omitempty"`

	// "enabled" field predicates.
	Enabled    *bool `json:"enabled,omitempty"`
	EnabledNEQ *bool `json:"enabledNEQ,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`

	// "vendor" edge predicates.
	HasVendor     *bool               `json:"hasVendor,omitempty"`
	HasVendorWith []*VendorWhereInput `json:"hasVendorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WarehouseWhereInput) AddPredicates(predicates ...predicate.Warehouse) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WarehouseWhereInput filter on the WarehouseQuery builder.
func (i *WarehouseWhereInput) Filter(q *WarehouseQuery) (*WarehouseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWarehouseWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWarehouseWhereInput is returned in case the WarehouseWhereInput is empty.
var ErrEmptyWarehouseWhereInput = errors.New("ent: empty predicate WarehouseWhereInput")

// P returns a predicate for filtering warehouses.
// An error is returned if the input is empty or invalid.
func (i *WarehouseWhereInput) P() (predicate.Warehouse, error) {
	var predicates []predicate.Warehouse
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, warehouse.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Warehouse, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, warehouse.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Warehouse, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, warehouse.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, warehouse.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, warehouse.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, warehouse.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, warehouse.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, warehouse.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, warehouse.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, warehouse.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, warehouse.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, warehouse.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, warehouse.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, warehouse.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, warehouse.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, warehouse.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, warehouse.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, warehouse.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, warehouse.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, warehouse.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, warehouse.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, warehouse.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, warehouse.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, warehouse.NameContainsFold(*i.NameContainsFold))
	}
	if i.LastUpdate != nil {
		predicates = append(predicates, warehouse.LastUpdateEQ(*i.LastUpdate))
	}
	if i.LastUpdateNEQ != nil {
		predicates = append(predicates, warehouse.LastUpdateNEQ(*i.LastUpdateNEQ))
	}
	if len(i.LastUpdateIn) > 0 {
		predicates = append(predicates, warehouse.LastUpdateIn(i.LastUpdateIn...))
	}
	if len(i.LastUpdateNotIn) > 0 {
		predicates = append(predicates, warehouse.LastUpdateNotIn(i.LastUpdateNotIn...))
	}
	if i.LastUpdateGT != nil {
		predicates = append(predicates, warehouse.LastUpdateGT(*i.LastUpdateGT))
	}
	if i.LastUpdateGTE != nil {
		predicates = append(predicates, warehouse.LastUpdateGTE(*i.LastUpdateGTE))
	}
	if i.LastUpdateLT != nil {
		predicates = append(predicates, warehouse.LastUpdateLT(*i.LastUpdateLT))
	}
	if i.LastUpdateLTE != nil {
		predicates = append(predicates, warehouse.LastUpdateLTE(*i.LastUpdateLTE))
	}
	if i.LastUpdateIsNil {
		predicates = append(predicates, warehouse.LastUpdateIsNil())
	}
	if i.LastUpdateNotNil {
		predicates = append(predicates, warehouse.LastUpdateNotNil())
	}
	if i.OriginalData != nil {
		predicates = append(predicates, warehouse.OriginalDataEQ(*i.OriginalData))
	}
	if i.OriginalDataNEQ != nil {
		predicates = append(predicates, warehouse.OriginalDataNEQ(*i.OriginalDataNEQ))
	}
	if len(i.OriginalDataIn) > 0 {
		predicates = append(predicates, warehouse.OriginalDataIn(i.OriginalDataIn...))
	}
	if len(i.OriginalDataNotIn) > 0 {
		predicates = append(predicates, warehouse.OriginalDataNotIn(i.OriginalDataNotIn...))
	}
	if i.OriginalDataGT != nil {
		predicates = append(predicates, warehouse.OriginalDataGT(*i.OriginalDataGT))
	}
	if i.OriginalDataGTE != nil {
		predicates = append(predicates, warehouse.OriginalDataGTE(*i.OriginalDataGTE))
	}
	if i.OriginalDataLT != nil {
		predicates = append(predicates, warehouse.OriginalDataLT(*i.OriginalDataLT))
	}
	if i.OriginalDataLTE != nil {
		predicates = append(predicates, warehouse.OriginalDataLTE(*i.OriginalDataLTE))
	}
	if i.OriginalDataContains != nil {
		predicates = append(predicates, warehouse.OriginalDataContains(*i.OriginalDataContains))
	}
	if i.OriginalDataHasPrefix != nil {
		predicates = append(predicates, warehouse.OriginalDataHasPrefix(*i.OriginalDataHasPrefix))
	}
	if i.OriginalDataHasSuffix != nil {
		predicates = append(predicates, warehouse.OriginalDataHasSuffix(*i.OriginalDataHasSuffix))
	}
	if i.OriginalDataIsNil {
		predicates = append(predicates, warehouse.OriginalDataIsNil())
	}
	if i.OriginalDataNotNil {
		predicates = append(predicates, warehouse.OriginalDataNotNil())
	}
	if i.OriginalDataEqualFold != nil {
		predicates = append(predicates, warehouse.OriginalDataEqualFold(*i.OriginalDataEqualFold))
	}
	if i.OriginalDataContainsFold != nil {
		predicates = append(predicates, warehouse.OriginalDataContainsFold(*i.OriginalDataContainsFold))
	}
	if i.Enabled != nil {
		predicates = append(predicates, warehouse.EnabledEQ(*i.Enabled))
	}
	if i.EnabledNEQ != nil {
		predicates = append(predicates, warehouse.EnabledNEQ(*i.EnabledNEQ))
	}

	if i.HasProducts != nil {
		p := warehouse.HasProducts()
		if !*i.HasProducts {
			p = warehouse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, warehouse.HasProductsWith(with...))
	}
	if i.HasVendor != nil {
		p := warehouse.HasVendor()
		if !*i.HasVendor {
			p = warehouse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVendorWith) > 0 {
		with := make([]predicate.Vendor, 0, len(i.HasVendorWith))
		for _, w := range i.HasVendorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVendorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, warehouse.HasVendorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWarehouseWhereInput
	case 1:
		return predicates[0], nil
	default:
		return warehouse.And(predicates...), nil
	}
}

// WebsiteWhereInput represents a where input for filtering Website queries.
type WebsiteWhereInput struct {
	Predicates []predicate.Website  `json:"-"`
	Not        *WebsiteWhereInput   `json:"not,omitempty"`
	Or         []*WebsiteWhereInput `json:"or,omitempty"`
	And        []*WebsiteWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WebsiteWhereInput) AddPredicates(predicates ...predicate.Website) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WebsiteWhereInput filter on the WebsiteQuery builder.
func (i *WebsiteWhereInput) Filter(q *WebsiteQuery) (*WebsiteQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWebsiteWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWebsiteWhereInput is returned in case the WebsiteWhereInput is empty.
var ErrEmptyWebsiteWhereInput = errors.New("ent: empty predicate WebsiteWhereInput")

// P returns a predicate for filtering websites.
// An error is returned if the input is empty or invalid.
func (i *WebsiteWhereInput) P() (predicate.Website, error) {
	var predicates []predicate.Website
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, website.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Website, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, website.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Website, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, website.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, website.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, website.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, website.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, website.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, website.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, website.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, website.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, website.IDLTE(*i.IDLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, website.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, website.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, website.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, website.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, website.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, website.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, website.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, website.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, website.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, website.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, website.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, website.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, website.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, website.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, website.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, website.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, website.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, website.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, website.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, website.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, website.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, website.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, website.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, website.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, website.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, website.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, website.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, website.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, website.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, website.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, website.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, website.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, website.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, website.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, website.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, website.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, website.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, website.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, website.URLContainsFold(*i.URLContainsFold))
	}

	if i.HasCompany != nil {
		p := website.HasCompany()
		if !*i.HasCompany {
			p = website.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, website.HasCompanyWith(with...))
	}
	if i.HasCountry != nil {
		p := website.HasCountry()
		if !*i.HasCountry {
			p = website.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, website.HasCountryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWebsiteWhereInput
	case 1:
		return predicates[0], nil
	default:
		return website.And(predicates...), nil
	}
}
