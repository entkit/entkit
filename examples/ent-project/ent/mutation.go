// Copyright 2019-present Facebook
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/diazoxide/ent-refine/examples/ent-project/ent/company"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/country"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/email"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/image"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/location"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/phone"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/predicate"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/product"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/schema/enums"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/vendor"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/warehouse"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/website"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCompany   = "Company"
	TypeCountry   = "Country"
	TypeEmail     = "Email"
	TypeImage     = "Image"
	TypeLocation  = "Location"
	TypePhone     = "Phone"
	TypeProduct   = "Product"
	TypeVendor    = "Vendor"
	TypeWarehouse = "Warehouse"
	TypeWebsite   = "Website"
)

// CompanyMutation represents an operation that mutates the Company nodes in the graph.
type CompanyMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	name                  *string
	logo                  *string
	description           *string
	clearedFields         map[string]struct{}
	countries             map[uuid.UUID]struct{}
	removedcountries      map[uuid.UUID]struct{}
	clearedcountries      bool
	phones                map[uuid.UUID]struct{}
	removedphones         map[uuid.UUID]struct{}
	clearedphones         bool
	emails                map[uuid.UUID]struct{}
	removedemails         map[uuid.UUID]struct{}
	clearedemails         bool
	websites              map[uuid.UUID]struct{}
	removedwebsites       map[uuid.UUID]struct{}
	clearedwebsites       bool
	locations             map[uuid.UUID]struct{}
	removedlocations      map[uuid.UUID]struct{}
	clearedlocations      bool
	logo_image            *uuid.UUID
	clearedlogo_image     bool
	cover_image           *uuid.UUID
	clearedcover_image    bool
	gallery_images        map[uuid.UUID]struct{}
	removedgallery_images map[uuid.UUID]struct{}
	clearedgallery_images bool
	done                  bool
	oldValue              func(context.Context) (*Company, error)
	predicates            []predicate.Company
}

var _ ent.Mutation = (*CompanyMutation)(nil)

// companyOption allows management of the mutation configuration using functional options.
type companyOption func(*CompanyMutation)

// newCompanyMutation creates new mutation for the Company entity.
func newCompanyMutation(c config, op Op, opts ...companyOption) *CompanyMutation {
	m := &CompanyMutation{
		config:        c,
		op:            op,
		typ:           TypeCompany,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyID sets the ID field of the mutation.
func withCompanyID(id uuid.UUID) companyOption {
	return func(m *CompanyMutation) {
		var (
			err   error
			once  sync.Once
			value *Company
		)
		m.oldValue = func(ctx context.Context) (*Company, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Company.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompany sets the old Company of the mutation.
func withCompany(node *Company) companyOption {
	return func(m *CompanyMutation) {
		m.oldValue = func(context.Context) (*Company, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Company entities.
func (m *CompanyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Company.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CompanyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompanyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompanyMutation) ResetName() {
	m.name = nil
}

// SetLogo sets the "logo" field.
func (m *CompanyMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *CompanyMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldLogo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *CompanyMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[company.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *CompanyMutation) LogoCleared() bool {
	_, ok := m.clearedFields[company.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *CompanyMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, company.FieldLogo)
}

// SetDescription sets the "description" field.
func (m *CompanyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CompanyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CompanyMutation) ResetDescription() {
	m.description = nil
}

// AddCountryIDs adds the "countries" edge to the Country entity by ids.
func (m *CompanyMutation) AddCountryIDs(ids ...uuid.UUID) {
	if m.countries == nil {
		m.countries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.countries[ids[i]] = struct{}{}
	}
}

// ClearCountries clears the "countries" edge to the Country entity.
func (m *CompanyMutation) ClearCountries() {
	m.clearedcountries = true
}

// CountriesCleared reports if the "countries" edge to the Country entity was cleared.
func (m *CompanyMutation) CountriesCleared() bool {
	return m.clearedcountries
}

// RemoveCountryIDs removes the "countries" edge to the Country entity by IDs.
func (m *CompanyMutation) RemoveCountryIDs(ids ...uuid.UUID) {
	if m.removedcountries == nil {
		m.removedcountries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.countries, ids[i])
		m.removedcountries[ids[i]] = struct{}{}
	}
}

// RemovedCountries returns the removed IDs of the "countries" edge to the Country entity.
func (m *CompanyMutation) RemovedCountriesIDs() (ids []uuid.UUID) {
	for id := range m.removedcountries {
		ids = append(ids, id)
	}
	return
}

// CountriesIDs returns the "countries" edge IDs in the mutation.
func (m *CompanyMutation) CountriesIDs() (ids []uuid.UUID) {
	for id := range m.countries {
		ids = append(ids, id)
	}
	return
}

// ResetCountries resets all changes to the "countries" edge.
func (m *CompanyMutation) ResetCountries() {
	m.countries = nil
	m.clearedcountries = false
	m.removedcountries = nil
}

// AddPhoneIDs adds the "phones" edge to the Phone entity by ids.
func (m *CompanyMutation) AddPhoneIDs(ids ...uuid.UUID) {
	if m.phones == nil {
		m.phones = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.phones[ids[i]] = struct{}{}
	}
}

// ClearPhones clears the "phones" edge to the Phone entity.
func (m *CompanyMutation) ClearPhones() {
	m.clearedphones = true
}

// PhonesCleared reports if the "phones" edge to the Phone entity was cleared.
func (m *CompanyMutation) PhonesCleared() bool {
	return m.clearedphones
}

// RemovePhoneIDs removes the "phones" edge to the Phone entity by IDs.
func (m *CompanyMutation) RemovePhoneIDs(ids ...uuid.UUID) {
	if m.removedphones == nil {
		m.removedphones = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.phones, ids[i])
		m.removedphones[ids[i]] = struct{}{}
	}
}

// RemovedPhones returns the removed IDs of the "phones" edge to the Phone entity.
func (m *CompanyMutation) RemovedPhonesIDs() (ids []uuid.UUID) {
	for id := range m.removedphones {
		ids = append(ids, id)
	}
	return
}

// PhonesIDs returns the "phones" edge IDs in the mutation.
func (m *CompanyMutation) PhonesIDs() (ids []uuid.UUID) {
	for id := range m.phones {
		ids = append(ids, id)
	}
	return
}

// ResetPhones resets all changes to the "phones" edge.
func (m *CompanyMutation) ResetPhones() {
	m.phones = nil
	m.clearedphones = false
	m.removedphones = nil
}

// AddEmailIDs adds the "emails" edge to the Email entity by ids.
func (m *CompanyMutation) AddEmailIDs(ids ...uuid.UUID) {
	if m.emails == nil {
		m.emails = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.emails[ids[i]] = struct{}{}
	}
}

// ClearEmails clears the "emails" edge to the Email entity.
func (m *CompanyMutation) ClearEmails() {
	m.clearedemails = true
}

// EmailsCleared reports if the "emails" edge to the Email entity was cleared.
func (m *CompanyMutation) EmailsCleared() bool {
	return m.clearedemails
}

// RemoveEmailIDs removes the "emails" edge to the Email entity by IDs.
func (m *CompanyMutation) RemoveEmailIDs(ids ...uuid.UUID) {
	if m.removedemails == nil {
		m.removedemails = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.emails, ids[i])
		m.removedemails[ids[i]] = struct{}{}
	}
}

// RemovedEmails returns the removed IDs of the "emails" edge to the Email entity.
func (m *CompanyMutation) RemovedEmailsIDs() (ids []uuid.UUID) {
	for id := range m.removedemails {
		ids = append(ids, id)
	}
	return
}

// EmailsIDs returns the "emails" edge IDs in the mutation.
func (m *CompanyMutation) EmailsIDs() (ids []uuid.UUID) {
	for id := range m.emails {
		ids = append(ids, id)
	}
	return
}

// ResetEmails resets all changes to the "emails" edge.
func (m *CompanyMutation) ResetEmails() {
	m.emails = nil
	m.clearedemails = false
	m.removedemails = nil
}

// AddWebsiteIDs adds the "websites" edge to the Website entity by ids.
func (m *CompanyMutation) AddWebsiteIDs(ids ...uuid.UUID) {
	if m.websites == nil {
		m.websites = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.websites[ids[i]] = struct{}{}
	}
}

// ClearWebsites clears the "websites" edge to the Website entity.
func (m *CompanyMutation) ClearWebsites() {
	m.clearedwebsites = true
}

// WebsitesCleared reports if the "websites" edge to the Website entity was cleared.
func (m *CompanyMutation) WebsitesCleared() bool {
	return m.clearedwebsites
}

// RemoveWebsiteIDs removes the "websites" edge to the Website entity by IDs.
func (m *CompanyMutation) RemoveWebsiteIDs(ids ...uuid.UUID) {
	if m.removedwebsites == nil {
		m.removedwebsites = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.websites, ids[i])
		m.removedwebsites[ids[i]] = struct{}{}
	}
}

// RemovedWebsites returns the removed IDs of the "websites" edge to the Website entity.
func (m *CompanyMutation) RemovedWebsitesIDs() (ids []uuid.UUID) {
	for id := range m.removedwebsites {
		ids = append(ids, id)
	}
	return
}

// WebsitesIDs returns the "websites" edge IDs in the mutation.
func (m *CompanyMutation) WebsitesIDs() (ids []uuid.UUID) {
	for id := range m.websites {
		ids = append(ids, id)
	}
	return
}

// ResetWebsites resets all changes to the "websites" edge.
func (m *CompanyMutation) ResetWebsites() {
	m.websites = nil
	m.clearedwebsites = false
	m.removedwebsites = nil
}

// AddLocationIDs adds the "locations" edge to the Location entity by ids.
func (m *CompanyMutation) AddLocationIDs(ids ...uuid.UUID) {
	if m.locations == nil {
		m.locations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.locations[ids[i]] = struct{}{}
	}
}

// ClearLocations clears the "locations" edge to the Location entity.
func (m *CompanyMutation) ClearLocations() {
	m.clearedlocations = true
}

// LocationsCleared reports if the "locations" edge to the Location entity was cleared.
func (m *CompanyMutation) LocationsCleared() bool {
	return m.clearedlocations
}

// RemoveLocationIDs removes the "locations" edge to the Location entity by IDs.
func (m *CompanyMutation) RemoveLocationIDs(ids ...uuid.UUID) {
	if m.removedlocations == nil {
		m.removedlocations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.locations, ids[i])
		m.removedlocations[ids[i]] = struct{}{}
	}
}

// RemovedLocations returns the removed IDs of the "locations" edge to the Location entity.
func (m *CompanyMutation) RemovedLocationsIDs() (ids []uuid.UUID) {
	for id := range m.removedlocations {
		ids = append(ids, id)
	}
	return
}

// LocationsIDs returns the "locations" edge IDs in the mutation.
func (m *CompanyMutation) LocationsIDs() (ids []uuid.UUID) {
	for id := range m.locations {
		ids = append(ids, id)
	}
	return
}

// ResetLocations resets all changes to the "locations" edge.
func (m *CompanyMutation) ResetLocations() {
	m.locations = nil
	m.clearedlocations = false
	m.removedlocations = nil
}

// SetLogoImageID sets the "logo_image" edge to the Image entity by id.
func (m *CompanyMutation) SetLogoImageID(id uuid.UUID) {
	m.logo_image = &id
}

// ClearLogoImage clears the "logo_image" edge to the Image entity.
func (m *CompanyMutation) ClearLogoImage() {
	m.clearedlogo_image = true
}

// LogoImageCleared reports if the "logo_image" edge to the Image entity was cleared.
func (m *CompanyMutation) LogoImageCleared() bool {
	return m.clearedlogo_image
}

// LogoImageID returns the "logo_image" edge ID in the mutation.
func (m *CompanyMutation) LogoImageID() (id uuid.UUID, exists bool) {
	if m.logo_image != nil {
		return *m.logo_image, true
	}
	return
}

// LogoImageIDs returns the "logo_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LogoImageID instead. It exists only for internal usage by the builders.
func (m *CompanyMutation) LogoImageIDs() (ids []uuid.UUID) {
	if id := m.logo_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLogoImage resets all changes to the "logo_image" edge.
func (m *CompanyMutation) ResetLogoImage() {
	m.logo_image = nil
	m.clearedlogo_image = false
}

// SetCoverImageID sets the "cover_image" edge to the Image entity by id.
func (m *CompanyMutation) SetCoverImageID(id uuid.UUID) {
	m.cover_image = &id
}

// ClearCoverImage clears the "cover_image" edge to the Image entity.
func (m *CompanyMutation) ClearCoverImage() {
	m.clearedcover_image = true
}

// CoverImageCleared reports if the "cover_image" edge to the Image entity was cleared.
func (m *CompanyMutation) CoverImageCleared() bool {
	return m.clearedcover_image
}

// CoverImageID returns the "cover_image" edge ID in the mutation.
func (m *CompanyMutation) CoverImageID() (id uuid.UUID, exists bool) {
	if m.cover_image != nil {
		return *m.cover_image, true
	}
	return
}

// CoverImageIDs returns the "cover_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoverImageID instead. It exists only for internal usage by the builders.
func (m *CompanyMutation) CoverImageIDs() (ids []uuid.UUID) {
	if id := m.cover_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoverImage resets all changes to the "cover_image" edge.
func (m *CompanyMutation) ResetCoverImage() {
	m.cover_image = nil
	m.clearedcover_image = false
}

// AddGalleryImageIDs adds the "gallery_images" edge to the Image entity by ids.
func (m *CompanyMutation) AddGalleryImageIDs(ids ...uuid.UUID) {
	if m.gallery_images == nil {
		m.gallery_images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.gallery_images[ids[i]] = struct{}{}
	}
}

// ClearGalleryImages clears the "gallery_images" edge to the Image entity.
func (m *CompanyMutation) ClearGalleryImages() {
	m.clearedgallery_images = true
}

// GalleryImagesCleared reports if the "gallery_images" edge to the Image entity was cleared.
func (m *CompanyMutation) GalleryImagesCleared() bool {
	return m.clearedgallery_images
}

// RemoveGalleryImageIDs removes the "gallery_images" edge to the Image entity by IDs.
func (m *CompanyMutation) RemoveGalleryImageIDs(ids ...uuid.UUID) {
	if m.removedgallery_images == nil {
		m.removedgallery_images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.gallery_images, ids[i])
		m.removedgallery_images[ids[i]] = struct{}{}
	}
}

// RemovedGalleryImages returns the removed IDs of the "gallery_images" edge to the Image entity.
func (m *CompanyMutation) RemovedGalleryImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedgallery_images {
		ids = append(ids, id)
	}
	return
}

// GalleryImagesIDs returns the "gallery_images" edge IDs in the mutation.
func (m *CompanyMutation) GalleryImagesIDs() (ids []uuid.UUID) {
	for id := range m.gallery_images {
		ids = append(ids, id)
	}
	return
}

// ResetGalleryImages resets all changes to the "gallery_images" edge.
func (m *CompanyMutation) ResetGalleryImages() {
	m.gallery_images = nil
	m.clearedgallery_images = false
	m.removedgallery_images = nil
}

// Where appends a list predicates to the CompanyMutation builder.
func (m *CompanyMutation) Where(ps ...predicate.Company) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Company, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Company).
func (m *CompanyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, company.FieldName)
	}
	if m.logo != nil {
		fields = append(fields, company.FieldLogo)
	}
	if m.description != nil {
		fields = append(fields, company.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case company.FieldName:
		return m.Name()
	case company.FieldLogo:
		return m.Logo()
	case company.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case company.FieldName:
		return m.OldName(ctx)
	case company.FieldLogo:
		return m.OldLogo(ctx)
	case company.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Company field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case company.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case company.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case company.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Company numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(company.FieldLogo) {
		fields = append(fields, company.FieldLogo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyMutation) ClearField(name string) error {
	switch name {
	case company.FieldLogo:
		m.ClearLogo()
		return nil
	}
	return fmt.Errorf("unknown Company nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyMutation) ResetField(name string) error {
	switch name {
	case company.FieldName:
		m.ResetName()
		return nil
	case company.FieldLogo:
		m.ResetLogo()
		return nil
	case company.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.countries != nil {
		edges = append(edges, company.EdgeCountries)
	}
	if m.phones != nil {
		edges = append(edges, company.EdgePhones)
	}
	if m.emails != nil {
		edges = append(edges, company.EdgeEmails)
	}
	if m.websites != nil {
		edges = append(edges, company.EdgeWebsites)
	}
	if m.locations != nil {
		edges = append(edges, company.EdgeLocations)
	}
	if m.logo_image != nil {
		edges = append(edges, company.EdgeLogoImage)
	}
	if m.cover_image != nil {
		edges = append(edges, company.EdgeCoverImage)
	}
	if m.gallery_images != nil {
		edges = append(edges, company.EdgeGalleryImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeCountries:
		ids := make([]ent.Value, 0, len(m.countries))
		for id := range m.countries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgePhones:
		ids := make([]ent.Value, 0, len(m.phones))
		for id := range m.phones {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeEmails:
		ids := make([]ent.Value, 0, len(m.emails))
		for id := range m.emails {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeWebsites:
		ids := make([]ent.Value, 0, len(m.websites))
		for id := range m.websites {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.locations))
		for id := range m.locations {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeLogoImage:
		if id := m.logo_image; id != nil {
			return []ent.Value{*id}
		}
	case company.EdgeCoverImage:
		if id := m.cover_image; id != nil {
			return []ent.Value{*id}
		}
	case company.EdgeGalleryImages:
		ids := make([]ent.Value, 0, len(m.gallery_images))
		for id := range m.gallery_images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedcountries != nil {
		edges = append(edges, company.EdgeCountries)
	}
	if m.removedphones != nil {
		edges = append(edges, company.EdgePhones)
	}
	if m.removedemails != nil {
		edges = append(edges, company.EdgeEmails)
	}
	if m.removedwebsites != nil {
		edges = append(edges, company.EdgeWebsites)
	}
	if m.removedlocations != nil {
		edges = append(edges, company.EdgeLocations)
	}
	if m.removedgallery_images != nil {
		edges = append(edges, company.EdgeGalleryImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeCountries:
		ids := make([]ent.Value, 0, len(m.removedcountries))
		for id := range m.removedcountries {
			ids = append(ids, id)
		}
		return ids
	case company.EdgePhones:
		ids := make([]ent.Value, 0, len(m.removedphones))
		for id := range m.removedphones {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeEmails:
		ids := make([]ent.Value, 0, len(m.removedemails))
		for id := range m.removedemails {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeWebsites:
		ids := make([]ent.Value, 0, len(m.removedwebsites))
		for id := range m.removedwebsites {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.removedlocations))
		for id := range m.removedlocations {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeGalleryImages:
		ids := make([]ent.Value, 0, len(m.removedgallery_images))
		for id := range m.removedgallery_images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedcountries {
		edges = append(edges, company.EdgeCountries)
	}
	if m.clearedphones {
		edges = append(edges, company.EdgePhones)
	}
	if m.clearedemails {
		edges = append(edges, company.EdgeEmails)
	}
	if m.clearedwebsites {
		edges = append(edges, company.EdgeWebsites)
	}
	if m.clearedlocations {
		edges = append(edges, company.EdgeLocations)
	}
	if m.clearedlogo_image {
		edges = append(edges, company.EdgeLogoImage)
	}
	if m.clearedcover_image {
		edges = append(edges, company.EdgeCoverImage)
	}
	if m.clearedgallery_images {
		edges = append(edges, company.EdgeGalleryImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyMutation) EdgeCleared(name string) bool {
	switch name {
	case company.EdgeCountries:
		return m.clearedcountries
	case company.EdgePhones:
		return m.clearedphones
	case company.EdgeEmails:
		return m.clearedemails
	case company.EdgeWebsites:
		return m.clearedwebsites
	case company.EdgeLocations:
		return m.clearedlocations
	case company.EdgeLogoImage:
		return m.clearedlogo_image
	case company.EdgeCoverImage:
		return m.clearedcover_image
	case company.EdgeGalleryImages:
		return m.clearedgallery_images
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyMutation) ClearEdge(name string) error {
	switch name {
	case company.EdgeLogoImage:
		m.ClearLogoImage()
		return nil
	case company.EdgeCoverImage:
		m.ClearCoverImage()
		return nil
	}
	return fmt.Errorf("unknown Company unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyMutation) ResetEdge(name string) error {
	switch name {
	case company.EdgeCountries:
		m.ResetCountries()
		return nil
	case company.EdgePhones:
		m.ResetPhones()
		return nil
	case company.EdgeEmails:
		m.ResetEmails()
		return nil
	case company.EdgeWebsites:
		m.ResetWebsites()
		return nil
	case company.EdgeLocations:
		m.ResetLocations()
		return nil
	case company.EdgeLogoImage:
		m.ResetLogoImage()
		return nil
	case company.EdgeCoverImage:
		m.ResetCoverImage()
		return nil
	case company.EdgeGalleryImages:
		m.ResetGalleryImages()
		return nil
	}
	return fmt.Errorf("unknown Company edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	code             *string
	clearedFields    map[string]struct{}
	companies        map[uuid.UUID]struct{}
	removedcompanies map[uuid.UUID]struct{}
	clearedcompanies bool
	phones           map[uuid.UUID]struct{}
	removedphones    map[uuid.UUID]struct{}
	clearedphones    bool
	emails           map[uuid.UUID]struct{}
	removedemails    map[uuid.UUID]struct{}
	clearedemails    bool
	websites         map[uuid.UUID]struct{}
	removedwebsites  map[uuid.UUID]struct{}
	clearedwebsites  bool
	locations        map[uuid.UUID]struct{}
	removedlocations map[uuid.UUID]struct{}
	clearedlocations bool
	done             bool
	oldValue         func(context.Context) (*Country, error)
	predicates       []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id uuid.UUID) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Country entities.
func (m *CountryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CountryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CountryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CountryMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *CountryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CountryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CountryMutation) ResetCode() {
	m.code = nil
}

// AddCompanyIDs adds the "companies" edge to the Company entity by ids.
func (m *CountryMutation) AddCompanyIDs(ids ...uuid.UUID) {
	if m.companies == nil {
		m.companies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.companies[ids[i]] = struct{}{}
	}
}

// ClearCompanies clears the "companies" edge to the Company entity.
func (m *CountryMutation) ClearCompanies() {
	m.clearedcompanies = true
}

// CompaniesCleared reports if the "companies" edge to the Company entity was cleared.
func (m *CountryMutation) CompaniesCleared() bool {
	return m.clearedcompanies
}

// RemoveCompanyIDs removes the "companies" edge to the Company entity by IDs.
func (m *CountryMutation) RemoveCompanyIDs(ids ...uuid.UUID) {
	if m.removedcompanies == nil {
		m.removedcompanies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.companies, ids[i])
		m.removedcompanies[ids[i]] = struct{}{}
	}
}

// RemovedCompanies returns the removed IDs of the "companies" edge to the Company entity.
func (m *CountryMutation) RemovedCompaniesIDs() (ids []uuid.UUID) {
	for id := range m.removedcompanies {
		ids = append(ids, id)
	}
	return
}

// CompaniesIDs returns the "companies" edge IDs in the mutation.
func (m *CountryMutation) CompaniesIDs() (ids []uuid.UUID) {
	for id := range m.companies {
		ids = append(ids, id)
	}
	return
}

// ResetCompanies resets all changes to the "companies" edge.
func (m *CountryMutation) ResetCompanies() {
	m.companies = nil
	m.clearedcompanies = false
	m.removedcompanies = nil
}

// AddPhoneIDs adds the "phones" edge to the Phone entity by ids.
func (m *CountryMutation) AddPhoneIDs(ids ...uuid.UUID) {
	if m.phones == nil {
		m.phones = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.phones[ids[i]] = struct{}{}
	}
}

// ClearPhones clears the "phones" edge to the Phone entity.
func (m *CountryMutation) ClearPhones() {
	m.clearedphones = true
}

// PhonesCleared reports if the "phones" edge to the Phone entity was cleared.
func (m *CountryMutation) PhonesCleared() bool {
	return m.clearedphones
}

// RemovePhoneIDs removes the "phones" edge to the Phone entity by IDs.
func (m *CountryMutation) RemovePhoneIDs(ids ...uuid.UUID) {
	if m.removedphones == nil {
		m.removedphones = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.phones, ids[i])
		m.removedphones[ids[i]] = struct{}{}
	}
}

// RemovedPhones returns the removed IDs of the "phones" edge to the Phone entity.
func (m *CountryMutation) RemovedPhonesIDs() (ids []uuid.UUID) {
	for id := range m.removedphones {
		ids = append(ids, id)
	}
	return
}

// PhonesIDs returns the "phones" edge IDs in the mutation.
func (m *CountryMutation) PhonesIDs() (ids []uuid.UUID) {
	for id := range m.phones {
		ids = append(ids, id)
	}
	return
}

// ResetPhones resets all changes to the "phones" edge.
func (m *CountryMutation) ResetPhones() {
	m.phones = nil
	m.clearedphones = false
	m.removedphones = nil
}

// AddEmailIDs adds the "emails" edge to the Email entity by ids.
func (m *CountryMutation) AddEmailIDs(ids ...uuid.UUID) {
	if m.emails == nil {
		m.emails = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.emails[ids[i]] = struct{}{}
	}
}

// ClearEmails clears the "emails" edge to the Email entity.
func (m *CountryMutation) ClearEmails() {
	m.clearedemails = true
}

// EmailsCleared reports if the "emails" edge to the Email entity was cleared.
func (m *CountryMutation) EmailsCleared() bool {
	return m.clearedemails
}

// RemoveEmailIDs removes the "emails" edge to the Email entity by IDs.
func (m *CountryMutation) RemoveEmailIDs(ids ...uuid.UUID) {
	if m.removedemails == nil {
		m.removedemails = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.emails, ids[i])
		m.removedemails[ids[i]] = struct{}{}
	}
}

// RemovedEmails returns the removed IDs of the "emails" edge to the Email entity.
func (m *CountryMutation) RemovedEmailsIDs() (ids []uuid.UUID) {
	for id := range m.removedemails {
		ids = append(ids, id)
	}
	return
}

// EmailsIDs returns the "emails" edge IDs in the mutation.
func (m *CountryMutation) EmailsIDs() (ids []uuid.UUID) {
	for id := range m.emails {
		ids = append(ids, id)
	}
	return
}

// ResetEmails resets all changes to the "emails" edge.
func (m *CountryMutation) ResetEmails() {
	m.emails = nil
	m.clearedemails = false
	m.removedemails = nil
}

// AddWebsiteIDs adds the "websites" edge to the Website entity by ids.
func (m *CountryMutation) AddWebsiteIDs(ids ...uuid.UUID) {
	if m.websites == nil {
		m.websites = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.websites[ids[i]] = struct{}{}
	}
}

// ClearWebsites clears the "websites" edge to the Website entity.
func (m *CountryMutation) ClearWebsites() {
	m.clearedwebsites = true
}

// WebsitesCleared reports if the "websites" edge to the Website entity was cleared.
func (m *CountryMutation) WebsitesCleared() bool {
	return m.clearedwebsites
}

// RemoveWebsiteIDs removes the "websites" edge to the Website entity by IDs.
func (m *CountryMutation) RemoveWebsiteIDs(ids ...uuid.UUID) {
	if m.removedwebsites == nil {
		m.removedwebsites = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.websites, ids[i])
		m.removedwebsites[ids[i]] = struct{}{}
	}
}

// RemovedWebsites returns the removed IDs of the "websites" edge to the Website entity.
func (m *CountryMutation) RemovedWebsitesIDs() (ids []uuid.UUID) {
	for id := range m.removedwebsites {
		ids = append(ids, id)
	}
	return
}

// WebsitesIDs returns the "websites" edge IDs in the mutation.
func (m *CountryMutation) WebsitesIDs() (ids []uuid.UUID) {
	for id := range m.websites {
		ids = append(ids, id)
	}
	return
}

// ResetWebsites resets all changes to the "websites" edge.
func (m *CountryMutation) ResetWebsites() {
	m.websites = nil
	m.clearedwebsites = false
	m.removedwebsites = nil
}

// AddLocationIDs adds the "locations" edge to the Location entity by ids.
func (m *CountryMutation) AddLocationIDs(ids ...uuid.UUID) {
	if m.locations == nil {
		m.locations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.locations[ids[i]] = struct{}{}
	}
}

// ClearLocations clears the "locations" edge to the Location entity.
func (m *CountryMutation) ClearLocations() {
	m.clearedlocations = true
}

// LocationsCleared reports if the "locations" edge to the Location entity was cleared.
func (m *CountryMutation) LocationsCleared() bool {
	return m.clearedlocations
}

// RemoveLocationIDs removes the "locations" edge to the Location entity by IDs.
func (m *CountryMutation) RemoveLocationIDs(ids ...uuid.UUID) {
	if m.removedlocations == nil {
		m.removedlocations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.locations, ids[i])
		m.removedlocations[ids[i]] = struct{}{}
	}
}

// RemovedLocations returns the removed IDs of the "locations" edge to the Location entity.
func (m *CountryMutation) RemovedLocationsIDs() (ids []uuid.UUID) {
	for id := range m.removedlocations {
		ids = append(ids, id)
	}
	return
}

// LocationsIDs returns the "locations" edge IDs in the mutation.
func (m *CountryMutation) LocationsIDs() (ids []uuid.UUID) {
	for id := range m.locations {
		ids = append(ids, id)
	}
	return
}

// ResetLocations resets all changes to the "locations" edge.
func (m *CountryMutation) ResetLocations() {
	m.locations = nil
	m.clearedlocations = false
	m.removedlocations = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Country, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, country.FieldName)
	}
	if m.code != nil {
		fields = append(fields, country.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldName:
		return m.Name()
	case country.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldName:
		return m.OldName(ctx)
	case country.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case country.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldName:
		m.ResetName()
		return nil
	case country.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.companies != nil {
		edges = append(edges, country.EdgeCompanies)
	}
	if m.phones != nil {
		edges = append(edges, country.EdgePhones)
	}
	if m.emails != nil {
		edges = append(edges, country.EdgeEmails)
	}
	if m.websites != nil {
		edges = append(edges, country.EdgeWebsites)
	}
	if m.locations != nil {
		edges = append(edges, country.EdgeLocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeCompanies:
		ids := make([]ent.Value, 0, len(m.companies))
		for id := range m.companies {
			ids = append(ids, id)
		}
		return ids
	case country.EdgePhones:
		ids := make([]ent.Value, 0, len(m.phones))
		for id := range m.phones {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeEmails:
		ids := make([]ent.Value, 0, len(m.emails))
		for id := range m.emails {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeWebsites:
		ids := make([]ent.Value, 0, len(m.websites))
		for id := range m.websites {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.locations))
		for id := range m.locations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcompanies != nil {
		edges = append(edges, country.EdgeCompanies)
	}
	if m.removedphones != nil {
		edges = append(edges, country.EdgePhones)
	}
	if m.removedemails != nil {
		edges = append(edges, country.EdgeEmails)
	}
	if m.removedwebsites != nil {
		edges = append(edges, country.EdgeWebsites)
	}
	if m.removedlocations != nil {
		edges = append(edges, country.EdgeLocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeCompanies:
		ids := make([]ent.Value, 0, len(m.removedcompanies))
		for id := range m.removedcompanies {
			ids = append(ids, id)
		}
		return ids
	case country.EdgePhones:
		ids := make([]ent.Value, 0, len(m.removedphones))
		for id := range m.removedphones {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeEmails:
		ids := make([]ent.Value, 0, len(m.removedemails))
		for id := range m.removedemails {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeWebsites:
		ids := make([]ent.Value, 0, len(m.removedwebsites))
		for id := range m.removedwebsites {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.removedlocations))
		for id := range m.removedlocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcompanies {
		edges = append(edges, country.EdgeCompanies)
	}
	if m.clearedphones {
		edges = append(edges, country.EdgePhones)
	}
	if m.clearedemails {
		edges = append(edges, country.EdgeEmails)
	}
	if m.clearedwebsites {
		edges = append(edges, country.EdgeWebsites)
	}
	if m.clearedlocations {
		edges = append(edges, country.EdgeLocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	case country.EdgeCompanies:
		return m.clearedcompanies
	case country.EdgePhones:
		return m.clearedphones
	case country.EdgeEmails:
		return m.clearedemails
	case country.EdgeWebsites:
		return m.clearedwebsites
	case country.EdgeLocations:
		return m.clearedlocations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgeCompanies:
		m.ResetCompanies()
		return nil
	case country.EdgePhones:
		m.ResetPhones()
		return nil
	case country.EdgeEmails:
		m.ResetEmails()
		return nil
	case country.EdgeWebsites:
		m.ResetWebsites()
		return nil
	case country.EdgeLocations:
		m.ResetLocations()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// EmailMutation represents an operation that mutates the Email nodes in the graph.
type EmailMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	title          *string
	description    *string
	address        *string
	clearedFields  map[string]struct{}
	company        *uuid.UUID
	clearedcompany bool
	country        *uuid.UUID
	clearedcountry bool
	done           bool
	oldValue       func(context.Context) (*Email, error)
	predicates     []predicate.Email
}

var _ ent.Mutation = (*EmailMutation)(nil)

// emailOption allows management of the mutation configuration using functional options.
type emailOption func(*EmailMutation)

// newEmailMutation creates new mutation for the Email entity.
func newEmailMutation(c config, op Op, opts ...emailOption) *EmailMutation {
	m := &EmailMutation{
		config:        c,
		op:            op,
		typ:           TypeEmail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailID sets the ID field of the mutation.
func withEmailID(id uuid.UUID) emailOption {
	return func(m *EmailMutation) {
		var (
			err   error
			once  sync.Once
			value *Email
		)
		m.oldValue = func(ctx context.Context) (*Email, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Email.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmail sets the old Email of the mutation.
func withEmail(node *Email) emailOption {
	return func(m *EmailMutation) {
		m.oldValue = func(context.Context) (*Email, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Email entities.
func (m *EmailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Email.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *EmailMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *EmailMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *EmailMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *EmailMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EmailMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *EmailMutation) ResetDescription() {
	m.description = nil
}

// SetAddress sets the "address" field.
func (m *EmailMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *EmailMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *EmailMutation) ResetAddress() {
	m.address = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *EmailMutation) SetCompanyID(id uuid.UUID) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *EmailMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *EmailMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *EmailMutation) CompanyID() (id uuid.UUID, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *EmailMutation) CompanyIDs() (ids []uuid.UUID) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *EmailMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *EmailMutation) SetCountryID(id uuid.UUID) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *EmailMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *EmailMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *EmailMutation) CountryID() (id uuid.UUID, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *EmailMutation) CountryIDs() (ids []uuid.UUID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *EmailMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// Where appends a list predicates to the EmailMutation builder.
func (m *EmailMutation) Where(ps ...predicate.Email) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Email, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Email).
func (m *EmailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.title != nil {
		fields = append(fields, email.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, email.FieldDescription)
	}
	if m.address != nil {
		fields = append(fields, email.FieldAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case email.FieldTitle:
		return m.Title()
	case email.FieldDescription:
		return m.Description()
	case email.FieldAddress:
		return m.Address()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case email.FieldTitle:
		return m.OldTitle(ctx)
	case email.FieldDescription:
		return m.OldDescription(ctx)
	case email.FieldAddress:
		return m.OldAddress(ctx)
	}
	return nil, fmt.Errorf("unknown Email field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case email.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case email.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case email.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	}
	return fmt.Errorf("unknown Email field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Email numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Email nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailMutation) ResetField(name string) error {
	switch name {
	case email.FieldTitle:
		m.ResetTitle()
		return nil
	case email.FieldDescription:
		m.ResetDescription()
		return nil
	case email.FieldAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown Email field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, email.EdgeCompany)
	}
	if m.country != nil {
		edges = append(edges, email.EdgeCountry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case email.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case email.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, email.EdgeCompany)
	}
	if m.clearedcountry {
		edges = append(edges, email.EdgeCountry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailMutation) EdgeCleared(name string) bool {
	switch name {
	case email.EdgeCompany:
		return m.clearedcompany
	case email.EdgeCountry:
		return m.clearedcountry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailMutation) ClearEdge(name string) error {
	switch name {
	case email.EdgeCompany:
		m.ClearCompany()
		return nil
	case email.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown Email unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailMutation) ResetEdge(name string) error {
	switch name {
	case email.EdgeCompany:
		m.ResetCompany()
		return nil
	case email.EdgeCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Email edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	title                  *string
	original_url           *string
	clearedFields          map[string]struct{}
	gallery_company        *uuid.UUID
	clearedgallery_company bool
	logo_company           *uuid.UUID
	clearedlogo_company    bool
	cover_company          *uuid.UUID
	clearedcover_company   bool
	done                   bool
	oldValue               func(context.Context) (*Image, error)
	predicates             []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id uuid.UUID) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Image entities.
func (m *ImageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ImageMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ImageMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ImageMutation) ResetTitle() {
	m.title = nil
}

// SetOriginalURL sets the "original_url" field.
func (m *ImageMutation) SetOriginalURL(s string) {
	m.original_url = &s
}

// OriginalURL returns the value of the "original_url" field in the mutation.
func (m *ImageMutation) OriginalURL() (r string, exists bool) {
	v := m.original_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalURL returns the old "original_url" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldOriginalURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalURL: %w", err)
	}
	return oldValue.OriginalURL, nil
}

// ResetOriginalURL resets all changes to the "original_url" field.
func (m *ImageMutation) ResetOriginalURL() {
	m.original_url = nil
}

// SetGalleryCompanyID sets the "gallery_company" edge to the Company entity by id.
func (m *ImageMutation) SetGalleryCompanyID(id uuid.UUID) {
	m.gallery_company = &id
}

// ClearGalleryCompany clears the "gallery_company" edge to the Company entity.
func (m *ImageMutation) ClearGalleryCompany() {
	m.clearedgallery_company = true
}

// GalleryCompanyCleared reports if the "gallery_company" edge to the Company entity was cleared.
func (m *ImageMutation) GalleryCompanyCleared() bool {
	return m.clearedgallery_company
}

// GalleryCompanyID returns the "gallery_company" edge ID in the mutation.
func (m *ImageMutation) GalleryCompanyID() (id uuid.UUID, exists bool) {
	if m.gallery_company != nil {
		return *m.gallery_company, true
	}
	return
}

// GalleryCompanyIDs returns the "gallery_company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GalleryCompanyID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) GalleryCompanyIDs() (ids []uuid.UUID) {
	if id := m.gallery_company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGalleryCompany resets all changes to the "gallery_company" edge.
func (m *ImageMutation) ResetGalleryCompany() {
	m.gallery_company = nil
	m.clearedgallery_company = false
}

// SetLogoCompanyID sets the "logo_company" edge to the Company entity by id.
func (m *ImageMutation) SetLogoCompanyID(id uuid.UUID) {
	m.logo_company = &id
}

// ClearLogoCompany clears the "logo_company" edge to the Company entity.
func (m *ImageMutation) ClearLogoCompany() {
	m.clearedlogo_company = true
}

// LogoCompanyCleared reports if the "logo_company" edge to the Company entity was cleared.
func (m *ImageMutation) LogoCompanyCleared() bool {
	return m.clearedlogo_company
}

// LogoCompanyID returns the "logo_company" edge ID in the mutation.
func (m *ImageMutation) LogoCompanyID() (id uuid.UUID, exists bool) {
	if m.logo_company != nil {
		return *m.logo_company, true
	}
	return
}

// LogoCompanyIDs returns the "logo_company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LogoCompanyID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) LogoCompanyIDs() (ids []uuid.UUID) {
	if id := m.logo_company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLogoCompany resets all changes to the "logo_company" edge.
func (m *ImageMutation) ResetLogoCompany() {
	m.logo_company = nil
	m.clearedlogo_company = false
}

// SetCoverCompanyID sets the "cover_company" edge to the Company entity by id.
func (m *ImageMutation) SetCoverCompanyID(id uuid.UUID) {
	m.cover_company = &id
}

// ClearCoverCompany clears the "cover_company" edge to the Company entity.
func (m *ImageMutation) ClearCoverCompany() {
	m.clearedcover_company = true
}

// CoverCompanyCleared reports if the "cover_company" edge to the Company entity was cleared.
func (m *ImageMutation) CoverCompanyCleared() bool {
	return m.clearedcover_company
}

// CoverCompanyID returns the "cover_company" edge ID in the mutation.
func (m *ImageMutation) CoverCompanyID() (id uuid.UUID, exists bool) {
	if m.cover_company != nil {
		return *m.cover_company, true
	}
	return
}

// CoverCompanyIDs returns the "cover_company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoverCompanyID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) CoverCompanyIDs() (ids []uuid.UUID) {
	if id := m.cover_company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoverCompany resets all changes to the "cover_company" edge.
func (m *ImageMutation) ResetCoverCompany() {
	m.cover_company = nil
	m.clearedcover_company = false
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Image, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.title != nil {
		fields = append(fields, image.FieldTitle)
	}
	if m.original_url != nil {
		fields = append(fields, image.FieldOriginalURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldTitle:
		return m.Title()
	case image.FieldOriginalURL:
		return m.OriginalURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldTitle:
		return m.OldTitle(ctx)
	case image.FieldOriginalURL:
		return m.OldOriginalURL(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case image.FieldOriginalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalURL(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldTitle:
		m.ResetTitle()
		return nil
	case image.FieldOriginalURL:
		m.ResetOriginalURL()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.gallery_company != nil {
		edges = append(edges, image.EdgeGalleryCompany)
	}
	if m.logo_company != nil {
		edges = append(edges, image.EdgeLogoCompany)
	}
	if m.cover_company != nil {
		edges = append(edges, image.EdgeCoverCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeGalleryCompany:
		if id := m.gallery_company; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeLogoCompany:
		if id := m.logo_company; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeCoverCompany:
		if id := m.cover_company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgallery_company {
		edges = append(edges, image.EdgeGalleryCompany)
	}
	if m.clearedlogo_company {
		edges = append(edges, image.EdgeLogoCompany)
	}
	if m.clearedcover_company {
		edges = append(edges, image.EdgeCoverCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeGalleryCompany:
		return m.clearedgallery_company
	case image.EdgeLogoCompany:
		return m.clearedlogo_company
	case image.EdgeCoverCompany:
		return m.clearedcover_company
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	case image.EdgeGalleryCompany:
		m.ClearGalleryCompany()
		return nil
	case image.EdgeLogoCompany:
		m.ClearLogoCompany()
		return nil
	case image.EdgeCoverCompany:
		m.ClearCoverCompany()
		return nil
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeGalleryCompany:
		m.ResetGalleryCompany()
		return nil
	case image.EdgeLogoCompany:
		m.ResetLogoCompany()
		return nil
	case image.EdgeCoverCompany:
		m.ResetCoverCompany()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	title          *string
	description    *string
	latitude       *float64
	addlatitude    *float64
	longitude      *float64
	addlongitude   *float64
	address        *string
	postcode       *string
	_type          *string
	state          *string
	suburb         *string
	street_type    *string
	street_name    *string
	clearedFields  map[string]struct{}
	company        *uuid.UUID
	clearedcompany bool
	country        *uuid.UUID
	clearedcountry bool
	done           bool
	oldValue       func(context.Context) (*Location, error)
	predicates     []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id uuid.UUID) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *LocationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *LocationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *LocationMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *LocationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LocationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *LocationMutation) ResetDescription() {
	m.description = nil
}

// SetLatitude sets the "latitude" field.
func (m *LocationMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *LocationMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *LocationMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *LocationMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *LocationMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetLongitude sets the "longitude" field.
func (m *LocationMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *LocationMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *LocationMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *LocationMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *LocationMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetAddress sets the "address" field.
func (m *LocationMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *LocationMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *LocationMutation) ResetAddress() {
	m.address = nil
}

// SetPostcode sets the "postcode" field.
func (m *LocationMutation) SetPostcode(s string) {
	m.postcode = &s
}

// Postcode returns the value of the "postcode" field in the mutation.
func (m *LocationMutation) Postcode() (r string, exists bool) {
	v := m.postcode
	if v == nil {
		return
	}
	return *v, true
}

// OldPostcode returns the old "postcode" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldPostcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostcode: %w", err)
	}
	return oldValue.Postcode, nil
}

// ResetPostcode resets all changes to the "postcode" field.
func (m *LocationMutation) ResetPostcode() {
	m.postcode = nil
}

// SetType sets the "type" field.
func (m *LocationMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *LocationMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LocationMutation) ResetType() {
	m._type = nil
}

// SetState sets the "state" field.
func (m *LocationMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *LocationMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *LocationMutation) ResetState() {
	m.state = nil
}

// SetSuburb sets the "suburb" field.
func (m *LocationMutation) SetSuburb(s string) {
	m.suburb = &s
}

// Suburb returns the value of the "suburb" field in the mutation.
func (m *LocationMutation) Suburb() (r string, exists bool) {
	v := m.suburb
	if v == nil {
		return
	}
	return *v, true
}

// OldSuburb returns the old "suburb" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldSuburb(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuburb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuburb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuburb: %w", err)
	}
	return oldValue.Suburb, nil
}

// ResetSuburb resets all changes to the "suburb" field.
func (m *LocationMutation) ResetSuburb() {
	m.suburb = nil
}

// SetStreetType sets the "street_type" field.
func (m *LocationMutation) SetStreetType(s string) {
	m.street_type = &s
}

// StreetType returns the value of the "street_type" field in the mutation.
func (m *LocationMutation) StreetType() (r string, exists bool) {
	v := m.street_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStreetType returns the old "street_type" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldStreetType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreetType: %w", err)
	}
	return oldValue.StreetType, nil
}

// ResetStreetType resets all changes to the "street_type" field.
func (m *LocationMutation) ResetStreetType() {
	m.street_type = nil
}

// SetStreetName sets the "street_name" field.
func (m *LocationMutation) SetStreetName(s string) {
	m.street_name = &s
}

// StreetName returns the value of the "street_name" field in the mutation.
func (m *LocationMutation) StreetName() (r string, exists bool) {
	v := m.street_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStreetName returns the old "street_name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldStreetName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreetName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreetName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreetName: %w", err)
	}
	return oldValue.StreetName, nil
}

// ResetStreetName resets all changes to the "street_name" field.
func (m *LocationMutation) ResetStreetName() {
	m.street_name = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *LocationMutation) SetCompanyID(id uuid.UUID) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *LocationMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *LocationMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *LocationMutation) CompanyID() (id uuid.UUID, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) CompanyIDs() (ids []uuid.UUID) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *LocationMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *LocationMutation) SetCountryID(id uuid.UUID) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *LocationMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *LocationMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *LocationMutation) CountryID() (id uuid.UUID, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) CountryIDs() (ids []uuid.UUID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *LocationMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.title != nil {
		fields = append(fields, location.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, location.FieldDescription)
	}
	if m.latitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	if m.address != nil {
		fields = append(fields, location.FieldAddress)
	}
	if m.postcode != nil {
		fields = append(fields, location.FieldPostcode)
	}
	if m._type != nil {
		fields = append(fields, location.FieldType)
	}
	if m.state != nil {
		fields = append(fields, location.FieldState)
	}
	if m.suburb != nil {
		fields = append(fields, location.FieldSuburb)
	}
	if m.street_type != nil {
		fields = append(fields, location.FieldStreetType)
	}
	if m.street_name != nil {
		fields = append(fields, location.FieldStreetName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldTitle:
		return m.Title()
	case location.FieldDescription:
		return m.Description()
	case location.FieldLatitude:
		return m.Latitude()
	case location.FieldLongitude:
		return m.Longitude()
	case location.FieldAddress:
		return m.Address()
	case location.FieldPostcode:
		return m.Postcode()
	case location.FieldType:
		return m.GetType()
	case location.FieldState:
		return m.State()
	case location.FieldSuburb:
		return m.Suburb()
	case location.FieldStreetType:
		return m.StreetType()
	case location.FieldStreetName:
		return m.StreetName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldTitle:
		return m.OldTitle(ctx)
	case location.FieldDescription:
		return m.OldDescription(ctx)
	case location.FieldLatitude:
		return m.OldLatitude(ctx)
	case location.FieldLongitude:
		return m.OldLongitude(ctx)
	case location.FieldAddress:
		return m.OldAddress(ctx)
	case location.FieldPostcode:
		return m.OldPostcode(ctx)
	case location.FieldType:
		return m.OldType(ctx)
	case location.FieldState:
		return m.OldState(ctx)
	case location.FieldSuburb:
		return m.OldSuburb(ctx)
	case location.FieldStreetType:
		return m.OldStreetType(ctx)
	case location.FieldStreetName:
		return m.OldStreetName(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case location.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case location.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case location.FieldPostcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostcode(v)
		return nil
	case location.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case location.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case location.FieldSuburb:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuburb(v)
		return nil
	case location.FieldStreetType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreetType(v)
		return nil
	case location.FieldStreetName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreetName(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case location.FieldLatitude:
		return m.AddedLatitude()
	case location.FieldLongitude:
		return m.AddedLongitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldTitle:
		m.ResetTitle()
		return nil
	case location.FieldDescription:
		m.ResetDescription()
		return nil
	case location.FieldLatitude:
		m.ResetLatitude()
		return nil
	case location.FieldLongitude:
		m.ResetLongitude()
		return nil
	case location.FieldAddress:
		m.ResetAddress()
		return nil
	case location.FieldPostcode:
		m.ResetPostcode()
		return nil
	case location.FieldType:
		m.ResetType()
		return nil
	case location.FieldState:
		m.ResetState()
		return nil
	case location.FieldSuburb:
		m.ResetSuburb()
		return nil
	case location.FieldStreetType:
		m.ResetStreetType()
		return nil
	case location.FieldStreetName:
		m.ResetStreetName()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, location.EdgeCompany)
	}
	if m.country != nil {
		edges = append(edges, location.EdgeCountry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, location.EdgeCompany)
	}
	if m.clearedcountry {
		edges = append(edges, location.EdgeCountry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeCompany:
		return m.clearedcompany
	case location.EdgeCountry:
		return m.clearedcountry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	case location.EdgeCompany:
		m.ClearCompany()
		return nil
	case location.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeCompany:
		m.ResetCompany()
		return nil
	case location.EdgeCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// PhoneMutation represents an operation that mutates the Phone nodes in the graph.
type PhoneMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	title          *string
	description    *string
	number         *string
	_type          *string
	clearedFields  map[string]struct{}
	company        *uuid.UUID
	clearedcompany bool
	country        *uuid.UUID
	clearedcountry bool
	done           bool
	oldValue       func(context.Context) (*Phone, error)
	predicates     []predicate.Phone
}

var _ ent.Mutation = (*PhoneMutation)(nil)

// phoneOption allows management of the mutation configuration using functional options.
type phoneOption func(*PhoneMutation)

// newPhoneMutation creates new mutation for the Phone entity.
func newPhoneMutation(c config, op Op, opts ...phoneOption) *PhoneMutation {
	m := &PhoneMutation{
		config:        c,
		op:            op,
		typ:           TypePhone,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPhoneID sets the ID field of the mutation.
func withPhoneID(id uuid.UUID) phoneOption {
	return func(m *PhoneMutation) {
		var (
			err   error
			once  sync.Once
			value *Phone
		)
		m.oldValue = func(ctx context.Context) (*Phone, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Phone.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPhone sets the old Phone of the mutation.
func withPhone(node *Phone) phoneOption {
	return func(m *PhoneMutation) {
		m.oldValue = func(context.Context) (*Phone, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PhoneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PhoneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Phone entities.
func (m *PhoneMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PhoneMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PhoneMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Phone.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *PhoneMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PhoneMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PhoneMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *PhoneMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PhoneMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PhoneMutation) ResetDescription() {
	m.description = nil
}

// SetNumber sets the "number" field.
func (m *PhoneMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *PhoneMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ResetNumber resets all changes to the "number" field.
func (m *PhoneMutation) ResetNumber() {
	m.number = nil
}

// SetType sets the "type" field.
func (m *PhoneMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PhoneMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Phone entity.
// If the Phone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhoneMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PhoneMutation) ResetType() {
	m._type = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *PhoneMutation) SetCompanyID(id uuid.UUID) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *PhoneMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *PhoneMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *PhoneMutation) CompanyID() (id uuid.UUID, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *PhoneMutation) CompanyIDs() (ids []uuid.UUID) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *PhoneMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *PhoneMutation) SetCountryID(id uuid.UUID) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *PhoneMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *PhoneMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *PhoneMutation) CountryID() (id uuid.UUID, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *PhoneMutation) CountryIDs() (ids []uuid.UUID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *PhoneMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// Where appends a list predicates to the PhoneMutation builder.
func (m *PhoneMutation) Where(ps ...predicate.Phone) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PhoneMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PhoneMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Phone, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PhoneMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PhoneMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Phone).
func (m *PhoneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PhoneMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.title != nil {
		fields = append(fields, phone.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, phone.FieldDescription)
	}
	if m.number != nil {
		fields = append(fields, phone.FieldNumber)
	}
	if m._type != nil {
		fields = append(fields, phone.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PhoneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case phone.FieldTitle:
		return m.Title()
	case phone.FieldDescription:
		return m.Description()
	case phone.FieldNumber:
		return m.Number()
	case phone.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PhoneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case phone.FieldTitle:
		return m.OldTitle(ctx)
	case phone.FieldDescription:
		return m.OldDescription(ctx)
	case phone.FieldNumber:
		return m.OldNumber(ctx)
	case phone.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Phone field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhoneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case phone.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case phone.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case phone.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case phone.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Phone field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PhoneMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PhoneMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhoneMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Phone numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PhoneMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PhoneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PhoneMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Phone nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PhoneMutation) ResetField(name string) error {
	switch name {
	case phone.FieldTitle:
		m.ResetTitle()
		return nil
	case phone.FieldDescription:
		m.ResetDescription()
		return nil
	case phone.FieldNumber:
		m.ResetNumber()
		return nil
	case phone.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Phone field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PhoneMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, phone.EdgeCompany)
	}
	if m.country != nil {
		edges = append(edges, phone.EdgeCountry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PhoneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case phone.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case phone.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PhoneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PhoneMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PhoneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, phone.EdgeCompany)
	}
	if m.clearedcountry {
		edges = append(edges, phone.EdgeCountry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PhoneMutation) EdgeCleared(name string) bool {
	switch name {
	case phone.EdgeCompany:
		return m.clearedcompany
	case phone.EdgeCountry:
		return m.clearedcountry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PhoneMutation) ClearEdge(name string) error {
	switch name {
	case phone.EdgeCompany:
		m.ClearCompany()
		return nil
	case phone.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown Phone unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PhoneMutation) ResetEdge(name string) error {
	switch name {
	case phone.EdgeCompany:
		m.ResetCompany()
		return nil
	case phone.EdgeCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Phone edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	description      *string
	image            *string
	url              *string
	last_sell        *time.Time
	created_at       *time.Time
	status           *enums.ProcessStatus
	build_status     *enums.ProcessStatus
	clearedFields    map[string]struct{}
	warehouse        *uuid.UUID
	clearedwarehouse bool
	vendor           *uuid.UUID
	clearedvendor    bool
	done             bool
	oldValue         func(context.Context) (*Product, error)
	predicates       []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id uuid.UUID) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
}

// SetImage sets the "image" field.
func (m *ProductMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *ProductMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *ProductMutation) ResetImage() {
	m.image = nil
}

// SetURL sets the "url" field.
func (m *ProductMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ProductMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ProductMutation) ResetURL() {
	m.url = nil
}

// SetLastSell sets the "last_sell" field.
func (m *ProductMutation) SetLastSell(t time.Time) {
	m.last_sell = &t
}

// LastSell returns the value of the "last_sell" field in the mutation.
func (m *ProductMutation) LastSell() (r time.Time, exists bool) {
	v := m.last_sell
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSell returns the old "last_sell" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLastSell(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSell is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSell: %w", err)
	}
	return oldValue.LastSell, nil
}

// ClearLastSell clears the value of the "last_sell" field.
func (m *ProductMutation) ClearLastSell() {
	m.last_sell = nil
	m.clearedFields[product.FieldLastSell] = struct{}{}
}

// LastSellCleared returns if the "last_sell" field was cleared in this mutation.
func (m *ProductMutation) LastSellCleared() bool {
	_, ok := m.clearedFields[product.FieldLastSell]
	return ok
}

// ResetLastSell resets all changes to the "last_sell" field.
func (m *ProductMutation) ResetLastSell() {
	m.last_sell = nil
	delete(m.clearedFields, product.FieldLastSell)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[product.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, product.FieldCreatedAt)
}

// SetStatus sets the "status" field.
func (m *ProductMutation) SetStatus(es enums.ProcessStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductMutation) Status() (r enums.ProcessStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStatus(ctx context.Context) (v enums.ProcessStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductMutation) ResetStatus() {
	m.status = nil
}

// SetBuildStatus sets the "build_status" field.
func (m *ProductMutation) SetBuildStatus(es enums.ProcessStatus) {
	m.build_status = &es
}

// BuildStatus returns the value of the "build_status" field in the mutation.
func (m *ProductMutation) BuildStatus() (r enums.ProcessStatus, exists bool) {
	v := m.build_status
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildStatus returns the old "build_status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldBuildStatus(ctx context.Context) (v enums.ProcessStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildStatus: %w", err)
	}
	return oldValue.BuildStatus, nil
}

// ResetBuildStatus resets all changes to the "build_status" field.
func (m *ProductMutation) ResetBuildStatus() {
	m.build_status = nil
}

// SetWarehouseID sets the "warehouse" edge to the Warehouse entity by id.
func (m *ProductMutation) SetWarehouseID(id uuid.UUID) {
	m.warehouse = &id
}

// ClearWarehouse clears the "warehouse" edge to the Warehouse entity.
func (m *ProductMutation) ClearWarehouse() {
	m.clearedwarehouse = true
}

// WarehouseCleared reports if the "warehouse" edge to the Warehouse entity was cleared.
func (m *ProductMutation) WarehouseCleared() bool {
	return m.clearedwarehouse
}

// WarehouseID returns the "warehouse" edge ID in the mutation.
func (m *ProductMutation) WarehouseID() (id uuid.UUID, exists bool) {
	if m.warehouse != nil {
		return *m.warehouse, true
	}
	return
}

// WarehouseIDs returns the "warehouse" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WarehouseID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) WarehouseIDs() (ids []uuid.UUID) {
	if id := m.warehouse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWarehouse resets all changes to the "warehouse" edge.
func (m *ProductMutation) ResetWarehouse() {
	m.warehouse = nil
	m.clearedwarehouse = false
}

// SetVendorID sets the "vendor" edge to the Vendor entity by id.
func (m *ProductMutation) SetVendorID(id uuid.UUID) {
	m.vendor = &id
}

// ClearVendor clears the "vendor" edge to the Vendor entity.
func (m *ProductMutation) ClearVendor() {
	m.clearedvendor = true
}

// VendorCleared reports if the "vendor" edge to the Vendor entity was cleared.
func (m *ProductMutation) VendorCleared() bool {
	return m.clearedvendor
}

// VendorID returns the "vendor" edge ID in the mutation.
func (m *ProductMutation) VendorID() (id uuid.UUID, exists bool) {
	if m.vendor != nil {
		return *m.vendor, true
	}
	return
}

// VendorIDs returns the "vendor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VendorID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) VendorIDs() (ids []uuid.UUID) {
	if id := m.vendor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVendor resets all changes to the "vendor" edge.
func (m *ProductMutation) ResetVendor() {
	m.vendor = nil
	m.clearedvendor = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.image != nil {
		fields = append(fields, product.FieldImage)
	}
	if m.url != nil {
		fields = append(fields, product.FieldURL)
	}
	if m.last_sell != nil {
		fields = append(fields, product.FieldLastSell)
	}
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, product.FieldStatus)
	}
	if m.build_status != nil {
		fields = append(fields, product.FieldBuildStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldName:
		return m.Name()
	case product.FieldDescription:
		return m.Description()
	case product.FieldImage:
		return m.Image()
	case product.FieldURL:
		return m.URL()
	case product.FieldLastSell:
		return m.LastSell()
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldStatus:
		return m.Status()
	case product.FieldBuildStatus:
		return m.BuildStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldImage:
		return m.OldImage(ctx)
	case product.FieldURL:
		return m.OldURL(ctx)
	case product.FieldLastSell:
		return m.OldLastSell(ctx)
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldStatus:
		return m.OldStatus(ctx)
	case product.FieldBuildStatus:
		return m.OldBuildStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case product.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case product.FieldLastSell:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSell(v)
		return nil
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(enums.ProcessStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case product.FieldBuildStatus:
		v, ok := value.(enums.ProcessStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldLastSell) {
		fields = append(fields, product.FieldLastSell)
	}
	if m.FieldCleared(product.FieldCreatedAt) {
		fields = append(fields, product.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldLastSell:
		m.ClearLastSell()
		return nil
	case product.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldImage:
		m.ResetImage()
		return nil
	case product.FieldURL:
		m.ResetURL()
		return nil
	case product.FieldLastSell:
		m.ResetLastSell()
		return nil
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldStatus:
		m.ResetStatus()
		return nil
	case product.FieldBuildStatus:
		m.ResetBuildStatus()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.warehouse != nil {
		edges = append(edges, product.EdgeWarehouse)
	}
	if m.vendor != nil {
		edges = append(edges, product.EdgeVendor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeWarehouse:
		if id := m.warehouse; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeVendor:
		if id := m.vendor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwarehouse {
		edges = append(edges, product.EdgeWarehouse)
	}
	if m.clearedvendor {
		edges = append(edges, product.EdgeVendor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeWarehouse:
		return m.clearedwarehouse
	case product.EdgeVendor:
		return m.clearedvendor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeWarehouse:
		m.ClearWarehouse()
		return nil
	case product.EdgeVendor:
		m.ClearVendor()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeWarehouse:
		m.ResetWarehouse()
		return nil
	case product.EdgeVendor:
		m.ResetVendor()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// VendorMutation represents an operation that mutates the Vendor nodes in the graph.
type VendorMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	schema            *string
	clearedFields     map[string]struct{}
	warehouses        map[uuid.UUID]struct{}
	removedwarehouses map[uuid.UUID]struct{}
	clearedwarehouses bool
	products          map[uuid.UUID]struct{}
	removedproducts   map[uuid.UUID]struct{}
	clearedproducts   bool
	done              bool
	oldValue          func(context.Context) (*Vendor, error)
	predicates        []predicate.Vendor
}

var _ ent.Mutation = (*VendorMutation)(nil)

// vendorOption allows management of the mutation configuration using functional options.
type vendorOption func(*VendorMutation)

// newVendorMutation creates new mutation for the Vendor entity.
func newVendorMutation(c config, op Op, opts ...vendorOption) *VendorMutation {
	m := &VendorMutation{
		config:        c,
		op:            op,
		typ:           TypeVendor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVendorID sets the ID field of the mutation.
func withVendorID(id uuid.UUID) vendorOption {
	return func(m *VendorMutation) {
		var (
			err   error
			once  sync.Once
			value *Vendor
		)
		m.oldValue = func(ctx context.Context) (*Vendor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vendor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVendor sets the old Vendor of the mutation.
func withVendor(node *Vendor) vendorOption {
	return func(m *VendorMutation) {
		m.oldValue = func(context.Context) (*Vendor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VendorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VendorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Vendor entities.
func (m *VendorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VendorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VendorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vendor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *VendorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VendorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Vendor entity.
// If the Vendor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VendorMutation) ResetName() {
	m.name = nil
}

// SetSchema sets the "schema" field.
func (m *VendorMutation) SetSchema(s string) {
	m.schema = &s
}

// Schema returns the value of the "schema" field in the mutation.
func (m *VendorMutation) Schema() (r string, exists bool) {
	v := m.schema
	if v == nil {
		return
	}
	return *v, true
}

// OldSchema returns the old "schema" field's value of the Vendor entity.
// If the Vendor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorMutation) OldSchema(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchema: %w", err)
	}
	return oldValue.Schema, nil
}

// ResetSchema resets all changes to the "schema" field.
func (m *VendorMutation) ResetSchema() {
	m.schema = nil
}

// AddWarehouseIDs adds the "warehouses" edge to the Warehouse entity by ids.
func (m *VendorMutation) AddWarehouseIDs(ids ...uuid.UUID) {
	if m.warehouses == nil {
		m.warehouses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.warehouses[ids[i]] = struct{}{}
	}
}

// ClearWarehouses clears the "warehouses" edge to the Warehouse entity.
func (m *VendorMutation) ClearWarehouses() {
	m.clearedwarehouses = true
}

// WarehousesCleared reports if the "warehouses" edge to the Warehouse entity was cleared.
func (m *VendorMutation) WarehousesCleared() bool {
	return m.clearedwarehouses
}

// RemoveWarehouseIDs removes the "warehouses" edge to the Warehouse entity by IDs.
func (m *VendorMutation) RemoveWarehouseIDs(ids ...uuid.UUID) {
	if m.removedwarehouses == nil {
		m.removedwarehouses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.warehouses, ids[i])
		m.removedwarehouses[ids[i]] = struct{}{}
	}
}

// RemovedWarehouses returns the removed IDs of the "warehouses" edge to the Warehouse entity.
func (m *VendorMutation) RemovedWarehousesIDs() (ids []uuid.UUID) {
	for id := range m.removedwarehouses {
		ids = append(ids, id)
	}
	return
}

// WarehousesIDs returns the "warehouses" edge IDs in the mutation.
func (m *VendorMutation) WarehousesIDs() (ids []uuid.UUID) {
	for id := range m.warehouses {
		ids = append(ids, id)
	}
	return
}

// ResetWarehouses resets all changes to the "warehouses" edge.
func (m *VendorMutation) ResetWarehouses() {
	m.warehouses = nil
	m.clearedwarehouses = false
	m.removedwarehouses = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *VendorMutation) AddProductIDs(ids ...uuid.UUID) {
	if m.products == nil {
		m.products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *VendorMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *VendorMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *VendorMutation) RemoveProductIDs(ids ...uuid.UUID) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *VendorMutation) RemovedProductsIDs() (ids []uuid.UUID) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *VendorMutation) ProductsIDs() (ids []uuid.UUID) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *VendorMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the VendorMutation builder.
func (m *VendorMutation) Where(ps ...predicate.Vendor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VendorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VendorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vendor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VendorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VendorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vendor).
func (m *VendorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VendorMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, vendor.FieldName)
	}
	if m.schema != nil {
		fields = append(fields, vendor.FieldSchema)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VendorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vendor.FieldName:
		return m.Name()
	case vendor.FieldSchema:
		return m.Schema()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VendorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vendor.FieldName:
		return m.OldName(ctx)
	case vendor.FieldSchema:
		return m.OldSchema(ctx)
	}
	return nil, fmt.Errorf("unknown Vendor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vendor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vendor.FieldSchema:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchema(v)
		return nil
	}
	return fmt.Errorf("unknown Vendor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VendorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VendorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Vendor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VendorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VendorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VendorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Vendor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VendorMutation) ResetField(name string) error {
	switch name {
	case vendor.FieldName:
		m.ResetName()
		return nil
	case vendor.FieldSchema:
		m.ResetSchema()
		return nil
	}
	return fmt.Errorf("unknown Vendor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VendorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.warehouses != nil {
		edges = append(edges, vendor.EdgeWarehouses)
	}
	if m.products != nil {
		edges = append(edges, vendor.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VendorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vendor.EdgeWarehouses:
		ids := make([]ent.Value, 0, len(m.warehouses))
		for id := range m.warehouses {
			ids = append(ids, id)
		}
		return ids
	case vendor.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VendorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedwarehouses != nil {
		edges = append(edges, vendor.EdgeWarehouses)
	}
	if m.removedproducts != nil {
		edges = append(edges, vendor.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VendorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vendor.EdgeWarehouses:
		ids := make([]ent.Value, 0, len(m.removedwarehouses))
		for id := range m.removedwarehouses {
			ids = append(ids, id)
		}
		return ids
	case vendor.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VendorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwarehouses {
		edges = append(edges, vendor.EdgeWarehouses)
	}
	if m.clearedproducts {
		edges = append(edges, vendor.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VendorMutation) EdgeCleared(name string) bool {
	switch name {
	case vendor.EdgeWarehouses:
		return m.clearedwarehouses
	case vendor.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VendorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Vendor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VendorMutation) ResetEdge(name string) error {
	switch name {
	case vendor.EdgeWarehouses:
		m.ResetWarehouses()
		return nil
	case vendor.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Vendor edge %s", name)
}

// WarehouseMutation represents an operation that mutates the Warehouse nodes in the graph.
type WarehouseMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name            *string
	last_update     *time.Time
	original_data   *string
	enabled         *bool
	filters         *[]string
	appendfilters   []string
	clearedFields   map[string]struct{}
	products        map[uuid.UUID]struct{}
	removedproducts map[uuid.UUID]struct{}
	clearedproducts bool
	vendor          *uuid.UUID
	clearedvendor   bool
	done            bool
	oldValue        func(context.Context) (*Warehouse, error)
	predicates      []predicate.Warehouse
}

var _ ent.Mutation = (*WarehouseMutation)(nil)

// warehouseOption allows management of the mutation configuration using functional options.
type warehouseOption func(*WarehouseMutation)

// newWarehouseMutation creates new mutation for the Warehouse entity.
func newWarehouseMutation(c config, op Op, opts ...warehouseOption) *WarehouseMutation {
	m := &WarehouseMutation{
		config:        c,
		op:            op,
		typ:           TypeWarehouse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWarehouseID sets the ID field of the mutation.
func withWarehouseID(id uuid.UUID) warehouseOption {
	return func(m *WarehouseMutation) {
		var (
			err   error
			once  sync.Once
			value *Warehouse
		)
		m.oldValue = func(ctx context.Context) (*Warehouse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Warehouse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWarehouse sets the old Warehouse of the mutation.
func withWarehouse(node *Warehouse) warehouseOption {
	return func(m *WarehouseMutation) {
		m.oldValue = func(context.Context) (*Warehouse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WarehouseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WarehouseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Warehouse entities.
func (m *WarehouseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WarehouseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WarehouseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Warehouse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WarehouseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WarehouseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WarehouseMutation) ResetName() {
	m.name = nil
}

// SetLastUpdate sets the "last_update" field.
func (m *WarehouseMutation) SetLastUpdate(t time.Time) {
	m.last_update = &t
}

// LastUpdate returns the value of the "last_update" field in the mutation.
func (m *WarehouseMutation) LastUpdate() (r time.Time, exists bool) {
	v := m.last_update
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdate returns the old "last_update" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldLastUpdate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdate: %w", err)
	}
	return oldValue.LastUpdate, nil
}

// ClearLastUpdate clears the value of the "last_update" field.
func (m *WarehouseMutation) ClearLastUpdate() {
	m.last_update = nil
	m.clearedFields[warehouse.FieldLastUpdate] = struct{}{}
}

// LastUpdateCleared returns if the "last_update" field was cleared in this mutation.
func (m *WarehouseMutation) LastUpdateCleared() bool {
	_, ok := m.clearedFields[warehouse.FieldLastUpdate]
	return ok
}

// ResetLastUpdate resets all changes to the "last_update" field.
func (m *WarehouseMutation) ResetLastUpdate() {
	m.last_update = nil
	delete(m.clearedFields, warehouse.FieldLastUpdate)
}

// SetOriginalData sets the "original_data" field.
func (m *WarehouseMutation) SetOriginalData(s string) {
	m.original_data = &s
}

// OriginalData returns the value of the "original_data" field in the mutation.
func (m *WarehouseMutation) OriginalData() (r string, exists bool) {
	v := m.original_data
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalData returns the old "original_data" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldOriginalData(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalData: %w", err)
	}
	return oldValue.OriginalData, nil
}

// ClearOriginalData clears the value of the "original_data" field.
func (m *WarehouseMutation) ClearOriginalData() {
	m.original_data = nil
	m.clearedFields[warehouse.FieldOriginalData] = struct{}{}
}

// OriginalDataCleared returns if the "original_data" field was cleared in this mutation.
func (m *WarehouseMutation) OriginalDataCleared() bool {
	_, ok := m.clearedFields[warehouse.FieldOriginalData]
	return ok
}

// ResetOriginalData resets all changes to the "original_data" field.
func (m *WarehouseMutation) ResetOriginalData() {
	m.original_data = nil
	delete(m.clearedFields, warehouse.FieldOriginalData)
}

// SetEnabled sets the "enabled" field.
func (m *WarehouseMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *WarehouseMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *WarehouseMutation) ResetEnabled() {
	m.enabled = nil
}

// SetFilters sets the "filters" field.
func (m *WarehouseMutation) SetFilters(s []string) {
	m.filters = &s
	m.appendfilters = nil
}

// Filters returns the value of the "filters" field in the mutation.
func (m *WarehouseMutation) Filters() (r []string, exists bool) {
	v := m.filters
	if v == nil {
		return
	}
	return *v, true
}

// OldFilters returns the old "filters" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldFilters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilters: %w", err)
	}
	return oldValue.Filters, nil
}

// AppendFilters adds s to the "filters" field.
func (m *WarehouseMutation) AppendFilters(s []string) {
	m.appendfilters = append(m.appendfilters, s...)
}

// AppendedFilters returns the list of values that were appended to the "filters" field in this mutation.
func (m *WarehouseMutation) AppendedFilters() ([]string, bool) {
	if len(m.appendfilters) == 0 {
		return nil, false
	}
	return m.appendfilters, true
}

// ClearFilters clears the value of the "filters" field.
func (m *WarehouseMutation) ClearFilters() {
	m.filters = nil
	m.appendfilters = nil
	m.clearedFields[warehouse.FieldFilters] = struct{}{}
}

// FiltersCleared returns if the "filters" field was cleared in this mutation.
func (m *WarehouseMutation) FiltersCleared() bool {
	_, ok := m.clearedFields[warehouse.FieldFilters]
	return ok
}

// ResetFilters resets all changes to the "filters" field.
func (m *WarehouseMutation) ResetFilters() {
	m.filters = nil
	m.appendfilters = nil
	delete(m.clearedFields, warehouse.FieldFilters)
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *WarehouseMutation) AddProductIDs(ids ...uuid.UUID) {
	if m.products == nil {
		m.products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *WarehouseMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *WarehouseMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *WarehouseMutation) RemoveProductIDs(ids ...uuid.UUID) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *WarehouseMutation) RemovedProductsIDs() (ids []uuid.UUID) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *WarehouseMutation) ProductsIDs() (ids []uuid.UUID) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *WarehouseMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// SetVendorID sets the "vendor" edge to the Vendor entity by id.
func (m *WarehouseMutation) SetVendorID(id uuid.UUID) {
	m.vendor = &id
}

// ClearVendor clears the "vendor" edge to the Vendor entity.
func (m *WarehouseMutation) ClearVendor() {
	m.clearedvendor = true
}

// VendorCleared reports if the "vendor" edge to the Vendor entity was cleared.
func (m *WarehouseMutation) VendorCleared() bool {
	return m.clearedvendor
}

// VendorID returns the "vendor" edge ID in the mutation.
func (m *WarehouseMutation) VendorID() (id uuid.UUID, exists bool) {
	if m.vendor != nil {
		return *m.vendor, true
	}
	return
}

// VendorIDs returns the "vendor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VendorID instead. It exists only for internal usage by the builders.
func (m *WarehouseMutation) VendorIDs() (ids []uuid.UUID) {
	if id := m.vendor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVendor resets all changes to the "vendor" edge.
func (m *WarehouseMutation) ResetVendor() {
	m.vendor = nil
	m.clearedvendor = false
}

// Where appends a list predicates to the WarehouseMutation builder.
func (m *WarehouseMutation) Where(ps ...predicate.Warehouse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WarehouseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WarehouseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Warehouse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WarehouseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WarehouseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Warehouse).
func (m *WarehouseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WarehouseMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, warehouse.FieldName)
	}
	if m.last_update != nil {
		fields = append(fields, warehouse.FieldLastUpdate)
	}
	if m.original_data != nil {
		fields = append(fields, warehouse.FieldOriginalData)
	}
	if m.enabled != nil {
		fields = append(fields, warehouse.FieldEnabled)
	}
	if m.filters != nil {
		fields = append(fields, warehouse.FieldFilters)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WarehouseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case warehouse.FieldName:
		return m.Name()
	case warehouse.FieldLastUpdate:
		return m.LastUpdate()
	case warehouse.FieldOriginalData:
		return m.OriginalData()
	case warehouse.FieldEnabled:
		return m.Enabled()
	case warehouse.FieldFilters:
		return m.Filters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WarehouseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case warehouse.FieldName:
		return m.OldName(ctx)
	case warehouse.FieldLastUpdate:
		return m.OldLastUpdate(ctx)
	case warehouse.FieldOriginalData:
		return m.OldOriginalData(ctx)
	case warehouse.FieldEnabled:
		return m.OldEnabled(ctx)
	case warehouse.FieldFilters:
		return m.OldFilters(ctx)
	}
	return nil, fmt.Errorf("unknown Warehouse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarehouseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case warehouse.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case warehouse.FieldLastUpdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdate(v)
		return nil
	case warehouse.FieldOriginalData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalData(v)
		return nil
	case warehouse.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case warehouse.FieldFilters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilters(v)
		return nil
	}
	return fmt.Errorf("unknown Warehouse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WarehouseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WarehouseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarehouseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Warehouse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WarehouseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(warehouse.FieldLastUpdate) {
		fields = append(fields, warehouse.FieldLastUpdate)
	}
	if m.FieldCleared(warehouse.FieldOriginalData) {
		fields = append(fields, warehouse.FieldOriginalData)
	}
	if m.FieldCleared(warehouse.FieldFilters) {
		fields = append(fields, warehouse.FieldFilters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WarehouseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WarehouseMutation) ClearField(name string) error {
	switch name {
	case warehouse.FieldLastUpdate:
		m.ClearLastUpdate()
		return nil
	case warehouse.FieldOriginalData:
		m.ClearOriginalData()
		return nil
	case warehouse.FieldFilters:
		m.ClearFilters()
		return nil
	}
	return fmt.Errorf("unknown Warehouse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WarehouseMutation) ResetField(name string) error {
	switch name {
	case warehouse.FieldName:
		m.ResetName()
		return nil
	case warehouse.FieldLastUpdate:
		m.ResetLastUpdate()
		return nil
	case warehouse.FieldOriginalData:
		m.ResetOriginalData()
		return nil
	case warehouse.FieldEnabled:
		m.ResetEnabled()
		return nil
	case warehouse.FieldFilters:
		m.ResetFilters()
		return nil
	}
	return fmt.Errorf("unknown Warehouse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WarehouseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.products != nil {
		edges = append(edges, warehouse.EdgeProducts)
	}
	if m.vendor != nil {
		edges = append(edges, warehouse.EdgeVendor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WarehouseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case warehouse.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case warehouse.EdgeVendor:
		if id := m.vendor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WarehouseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproducts != nil {
		edges = append(edges, warehouse.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WarehouseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case warehouse.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WarehouseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproducts {
		edges = append(edges, warehouse.EdgeProducts)
	}
	if m.clearedvendor {
		edges = append(edges, warehouse.EdgeVendor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WarehouseMutation) EdgeCleared(name string) bool {
	switch name {
	case warehouse.EdgeProducts:
		return m.clearedproducts
	case warehouse.EdgeVendor:
		return m.clearedvendor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WarehouseMutation) ClearEdge(name string) error {
	switch name {
	case warehouse.EdgeVendor:
		m.ClearVendor()
		return nil
	}
	return fmt.Errorf("unknown Warehouse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WarehouseMutation) ResetEdge(name string) error {
	switch name {
	case warehouse.EdgeProducts:
		m.ResetProducts()
		return nil
	case warehouse.EdgeVendor:
		m.ResetVendor()
		return nil
	}
	return fmt.Errorf("unknown Warehouse edge %s", name)
}

// WebsiteMutation represents an operation that mutates the Website nodes in the graph.
type WebsiteMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	title          *string
	description    *string
	url            *string
	clearedFields  map[string]struct{}
	company        *uuid.UUID
	clearedcompany bool
	country        *uuid.UUID
	clearedcountry bool
	done           bool
	oldValue       func(context.Context) (*Website, error)
	predicates     []predicate.Website
}

var _ ent.Mutation = (*WebsiteMutation)(nil)

// websiteOption allows management of the mutation configuration using functional options.
type websiteOption func(*WebsiteMutation)

// newWebsiteMutation creates new mutation for the Website entity.
func newWebsiteMutation(c config, op Op, opts ...websiteOption) *WebsiteMutation {
	m := &WebsiteMutation{
		config:        c,
		op:            op,
		typ:           TypeWebsite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebsiteID sets the ID field of the mutation.
func withWebsiteID(id uuid.UUID) websiteOption {
	return func(m *WebsiteMutation) {
		var (
			err   error
			once  sync.Once
			value *Website
		)
		m.oldValue = func(ctx context.Context) (*Website, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Website.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebsite sets the old Website of the mutation.
func withWebsite(node *Website) websiteOption {
	return func(m *WebsiteMutation) {
		m.oldValue = func(context.Context) (*Website, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebsiteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebsiteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Website entities.
func (m *WebsiteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebsiteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebsiteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Website.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *WebsiteMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *WebsiteMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *WebsiteMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *WebsiteMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WebsiteMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *WebsiteMutation) ResetDescription() {
	m.description = nil
}

// SetURL sets the "url" field.
func (m *WebsiteMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *WebsiteMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Website entity.
// If the Website object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebsiteMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *WebsiteMutation) ResetURL() {
	m.url = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *WebsiteMutation) SetCompanyID(id uuid.UUID) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *WebsiteMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *WebsiteMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *WebsiteMutation) CompanyID() (id uuid.UUID, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *WebsiteMutation) CompanyIDs() (ids []uuid.UUID) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *WebsiteMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *WebsiteMutation) SetCountryID(id uuid.UUID) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *WebsiteMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *WebsiteMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *WebsiteMutation) CountryID() (id uuid.UUID, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *WebsiteMutation) CountryIDs() (ids []uuid.UUID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *WebsiteMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// Where appends a list predicates to the WebsiteMutation builder.
func (m *WebsiteMutation) Where(ps ...predicate.Website) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebsiteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebsiteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Website, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebsiteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebsiteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Website).
func (m *WebsiteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebsiteMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.title != nil {
		fields = append(fields, website.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, website.FieldDescription)
	}
	if m.url != nil {
		fields = append(fields, website.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebsiteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case website.FieldTitle:
		return m.Title()
	case website.FieldDescription:
		return m.Description()
	case website.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebsiteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case website.FieldTitle:
		return m.OldTitle(ctx)
	case website.FieldDescription:
		return m.OldDescription(ctx)
	case website.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Website field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebsiteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case website.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case website.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case website.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Website field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebsiteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebsiteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebsiteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Website numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebsiteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebsiteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebsiteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Website nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebsiteMutation) ResetField(name string) error {
	switch name {
	case website.FieldTitle:
		m.ResetTitle()
		return nil
	case website.FieldDescription:
		m.ResetDescription()
		return nil
	case website.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Website field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebsiteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, website.EdgeCompany)
	}
	if m.country != nil {
		edges = append(edges, website.EdgeCountry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebsiteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case website.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case website.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebsiteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebsiteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebsiteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, website.EdgeCompany)
	}
	if m.clearedcountry {
		edges = append(edges, website.EdgeCountry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebsiteMutation) EdgeCleared(name string) bool {
	switch name {
	case website.EdgeCompany:
		return m.clearedcompany
	case website.EdgeCountry:
		return m.clearedcountry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebsiteMutation) ClearEdge(name string) error {
	switch name {
	case website.EdgeCompany:
		m.ClearCompany()
		return nil
	case website.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown Website unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebsiteMutation) ResetEdge(name string) error {
	switch name {
	case website.EdgeCompany:
		m.ResetCompany()
		return nil
	case website.EdgeCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Website edge %s", name)
}
